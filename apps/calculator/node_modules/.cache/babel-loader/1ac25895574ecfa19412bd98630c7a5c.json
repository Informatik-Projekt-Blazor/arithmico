{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = checkCandidates;\n\nvar _eval = _interopRequireDefault(require(\"../../../../eval\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e2) {\n          throw _e2;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e3) {\n      didErr = true;\n      err = _e3;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nvar NEWTON_MAX_ITERATIONS = 32;\nvar BISECTION_MAX_ITERATIONS = Math.pow(2, 7);\nvar EPSILON_Y_COEFFICIENT = Math.pow(2, 7);\n\nfunction evaluatePosition(expression, value, context, position) {\n  value.value = position;\n  var result = (0, _eval[\"default\"])(expression, context);\n  if (result.type === 'number') return result.value;\n  throw 'invalid result';\n}\n\nfunction checkCandidateWithNewton(expression, candidate, value, context) {\n  var _candidate = _slicedToArray(candidate, 2),\n      leftLimit = _candidate[0],\n      rightLimit = _candidate[1];\n\n  var position = leftLimit + (rightLimit - leftLimit) / 2;\n  var epsilonY = Math.max(Math.abs(evaluatePosition(expression, value, context, leftLimit)), Math.abs(evaluatePosition(expression, value, context, rightLimit))) * Number.EPSILON * EPSILON_Y_COEFFICIENT;\n\n  for (var i = 0; i < NEWTON_MAX_ITERATIONS; i++) {\n    var y1 = evaluatePosition(expression, value, context, position);\n\n    if (Math.abs(y1) <= epsilonY) {\n      return position;\n    }\n\n    var x2 = position + Math.max(Math.abs(y1), Math.abs(position)) * 16 * Number.EPSILON;\n    var y2 = evaluatePosition(expression, value, context, x2);\n    var derivative = (y2 - y1) / (x2 - position);\n    var nextPosition = position - y1 / derivative;\n\n    if (!Number.isFinite(derivative) || nextPosition < leftLimit || nextPosition > rightLimit || nextPosition === leftLimit || nextPosition === rightLimit) {\n      return;\n    }\n\n    if (nextPosition >= leftLimit && nextPosition <= position) {\n      rightLimit = position;\n      position = nextPosition;\n    } else if (nextPosition > position && nextPosition <= rightLimit) {\n      leftLimit = position;\n      position = nextPosition;\n    }\n  }\n}\n\nfunction checkCandidateWithBisection(expression, candidate, value, context) {\n  var _candidate2 = _slicedToArray(candidate, 2),\n      leftX = _candidate2[0],\n      rightX = _candidate2[1];\n\n  var leftY = Math.abs(evaluatePosition(expression, value, context, leftX));\n  var rightY = Math.abs(evaluatePosition(expression, value, context, rightX));\n  var epsilonY = Math.max(leftY, rightY) * Number.EPSILON * EPSILON_Y_COEFFICIENT;\n\n  for (var i = 0; i < BISECTION_MAX_ITERATIONS; i++) {\n    var newX = leftX + (rightX - leftX) / 2;\n    var newY = Math.abs(evaluatePosition(expression, value, context, newX));\n\n    if (newY <= epsilonY) {\n      return newX;\n    }\n\n    if (newY > leftY && newY > rightY) {\n      return;\n    }\n\n    if (leftY < rightY) {\n      rightX = newX;\n      rightY = newY;\n    } else {\n      leftX = newX;\n      leftY = newY;\n    }\n  }\n}\n\nfunction checkCandidates(expression, candidates, value, context) {\n  var results = [];\n\n  var _iterator = _createForOfIteratorHelper(candidates),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var candidate = _step.value;\n      var newtonResult = checkCandidateWithNewton(expression, candidate, value, context);\n\n      if (Number.isFinite(newtonResult)) {\n        results.push(newtonResult);\n        continue;\n      }\n\n      var bisectionResult = checkCandidateWithBisection(expression, candidate, value, context);\n\n      if (Number.isFinite(bisectionResult)) {\n        results.push(bisectionResult);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return results;\n}","map":{"version":3,"mappings":"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","names":["NEWTON_MAX_ITERATIONS","BISECTION_MAX_ITERATIONS","Math","pow","EPSILON_Y_COEFFICIENT","evaluatePosition","expression","value","context","position","result","type","checkCandidateWithNewton","candidate","leftLimit","rightLimit","epsilonY","max","abs","Number","EPSILON","i","y1","x2","y2","derivative","nextPosition","isFinite","checkCandidateWithBisection","leftX","rightX","leftY","rightY","newX","newY","checkCandidates","candidates","results","newtonResult","push","bisectionResult","_iterator"],"sources":["/home/behrenle/Projects/private/arithmico-calculator/node_modules/@behrenle/number-cruncher/src/plugins/core/nsolve/utils/check-candidates.ts"],"sourcesContent":["import { Context } from './../../../../types/Context';\nimport { NumberNode } from './../../../../types/SyntaxTreeNodes';\nimport { SyntaxTreeNode } from '../../../../types';\nimport { CandidateIntervall } from './../types';\nimport evaluate from '../../../../eval';\n\nconst NEWTON_MAX_ITERATIONS = 32;\nconst BISECTION_MAX_ITERATIONS = Math.pow(2, 7);\nconst EPSILON_Y_COEFFICIENT = Math.pow(2, 7);\n\nfunction evaluatePosition(expression: SyntaxTreeNode, value: NumberNode, context: Context, position: number) {\n    value.value = position;\n    const result = evaluate(expression, context);\n\n    if (result.type === 'number') return result.value;\n\n    throw 'invalid result';\n}\n\nfunction checkCandidateWithNewton(\n    expression: SyntaxTreeNode,\n    candidate: CandidateIntervall,\n    value: NumberNode,\n    context: Context,\n) {\n    let [leftLimit, rightLimit] = candidate;\n    let position = leftLimit + (rightLimit - leftLimit) / 2;\n    const epsilonY =\n        Math.max(\n            Math.abs(evaluatePosition(expression, value, context, leftLimit)),\n            Math.abs(evaluatePosition(expression, value, context, rightLimit)),\n        ) *\n        Number.EPSILON *\n        EPSILON_Y_COEFFICIENT;\n\n    for (let i = 0; i < NEWTON_MAX_ITERATIONS; i++) {\n        const y1 = evaluatePosition(expression, value, context, position);\n\n        if (Math.abs(y1) <= epsilonY) {\n            return position;\n        }\n\n        const x2 = position + Math.max(Math.abs(y1), Math.abs(position)) * 16 * Number.EPSILON;\n        const y2 = evaluatePosition(expression, value, context, x2);\n        const derivative = (y2 - y1) / (x2 - position);\n        const nextPosition = position - y1 / derivative;\n\n        if (\n            !Number.isFinite(derivative) ||\n            nextPosition < leftLimit ||\n            nextPosition > rightLimit ||\n            nextPosition === leftLimit ||\n            nextPosition === rightLimit\n        ) {\n            return;\n        }\n\n        if (nextPosition >= leftLimit && nextPosition <= position) {\n            rightLimit = position;\n            position = nextPosition;\n        } else if (nextPosition > position && nextPosition <= rightLimit) {\n            leftLimit = position;\n            position = nextPosition;\n        }\n    }\n}\n\nfunction checkCandidateWithBisection(\n    expression: SyntaxTreeNode,\n    candidate: CandidateIntervall,\n    value: NumberNode,\n    context: Context,\n) {\n    let [leftX, rightX] = candidate;\n    let leftY = Math.abs(evaluatePosition(expression, value, context, leftX));\n    let rightY = Math.abs(evaluatePosition(expression, value, context, rightX));\n    const epsilonY = Math.max(leftY, rightY) * Number.EPSILON * EPSILON_Y_COEFFICIENT;\n\n    for (let i = 0; i < BISECTION_MAX_ITERATIONS; i++) {\n        const newX = leftX + (rightX - leftX) / 2;\n        const newY = Math.abs(evaluatePosition(expression, value, context, newX));\n\n        if (newY <= epsilonY) {\n            return newX;\n        }\n\n        if (newY > leftY && newY > rightY) {\n            return;\n        }\n\n        if (leftY < rightY) {\n            rightX = newX;\n            rightY = newY;\n        } else {\n            leftX = newX;\n            leftY = newY;\n        }\n    }\n}\n\nexport default function checkCandidates(\n    expression: SyntaxTreeNode,\n    candidates: CandidateIntervall[],\n    value: NumberNode,\n    context: Context,\n): number[] {\n    const results: number[] = [];\n\n    for (const candidate of candidates) {\n        const newtonResult = checkCandidateWithNewton(expression, candidate, value, context);\n        if (Number.isFinite(newtonResult)) {\n            results.push(newtonResult);\n            continue;\n        }\n\n        const bisectionResult = checkCandidateWithBisection(expression, candidate, value, context);\n        if (Number.isFinite(bisectionResult)) {\n            results.push(bisectionResult);\n        }\n    }\n\n    return results;\n}\n"]},"metadata":{},"sourceType":"script"}