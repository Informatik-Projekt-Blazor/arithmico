{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _normalizeUtils = require(\"./../../utils/normalize-utils\");\n\nvar _ = _interopRequireDefault(require(\"..\"));\n\nvar _eval = _interopRequireDefault(require(\"../../eval\"));\n\nvar _Plus = _interopRequireDefault(require(\"../../create/Plus\"));\n\nvar _symbolicUtils = require(\"../../utils/symbolic-utils\");\n\nvar _NumberNode = _interopRequireDefault(require(\"../../create/NumberNode\"));\n\nvar _equals = _interopRequireDefault(require(\"../../equals/equals\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar evaluateIfPossible = function evaluateIfPossible(node, context) {\n  if (!(0, _symbolicUtils.containsVariables)(node, context)) {\n    return (0, _eval[\"default\"])(node, context);\n  }\n};\n\nvar normalizeChildren = function normalizeChildren(node, context) {\n  if (node.type !== 'plus') {\n    return;\n  }\n\n  return (0, _Plus[\"default\"])((0, _[\"default\"])(node.left, context), (0, _[\"default\"])(node.right, context));\n};\n\nvar rotateIfLeftChildPlus = function rotateIfLeftChildPlus(node, context) {\n  if (!(node.type === 'plus' && node.left.type === 'plus')) {\n    return;\n  }\n\n  var rotatedNode = (0, _Plus[\"default\"])(node.left.left, (0, _Plus[\"default\"])(node.left.right, node.right));\n  return (0, _[\"default\"])(rotatedNode, context);\n};\n\nvar combineLeftChildWithRightChildLeftChild = function combineLeftChildWithRightChildLeftChild(node, context) {\n  if (!(node.type === 'plus' && !(0, _symbolicUtils.containsVariables)(node.left, context) && node.right.type === 'plus' && !(0, _symbolicUtils.containsVariables)(node.right.left, context))) {\n    return;\n  }\n\n  var normalizedNode = (0, _Plus[\"default\"])((0, _eval[\"default\"])((0, _Plus[\"default\"])(node.left, node.right.left), context), node.right.right);\n  return (0, _[\"default\"])(normalizedNode, context);\n};\n\nvar moveVariablesRight = function moveVariablesRight(node, context) {\n  if (node.type !== 'plus') {\n    return;\n  }\n\n  if (node.right.type === 'plus') {\n    if ((0, _symbolicUtils.containsVariables)(node.left, context) && !(0, _symbolicUtils.containsVariables)(node.right.left, context)) {\n      return (0, _[\"default\"])((0, _Plus[\"default\"])(node.right.left, (0, _Plus[\"default\"])(node.left, node.right.right)), context);\n    }\n  } else {\n    if ((0, _symbolicUtils.containsVariables)(node.left, context) && !(0, _symbolicUtils.containsVariables)(node.right, context)) {\n      return (0, _[\"default\"])((0, _Plus[\"default\"])(node.right, node.left), context);\n    }\n  }\n};\n\nvar combineMultiples = function combineMultiples(node, context) {\n  var summands = (0, _symbolicUtils.convertOperatorChainToList)('plus', node);\n\n  if (summands.length < 2) {\n    return;\n  }\n\n  var results = [];\n  var replaced = [];\n\n  for (var i = 0; i < summands.length; i++) {\n    if (replaced.includes(i)) {\n      continue;\n    }\n\n    var leftFactors = (0, _symbolicUtils.convertOperatorChainToList)('times', summands[i]);\n    var leftCoefficients = getCoefficients(leftFactors);\n    var leftFactorsWithoutCoefficients = getFactprsWotjpitCoefficients(leftFactors);\n\n    for (var j = i + 1; j < summands.length; j++) {\n      if (replaced.includes(j)) {\n        continue;\n      }\n\n      var rightFactors = (0, _symbolicUtils.convertOperatorChainToList)('times', summands[j]);\n      var rightCoefficients = getCoefficients(rightFactors);\n      var rightFactorsWithoutCoefficients = getFactprsWotjpitCoefficients(rightFactors);\n\n      if (factorsEquals(leftFactorsWithoutCoefficients, rightFactorsWithoutCoefficients)) {\n        var newCoefficient = (0, _[\"default\"])((0, _Plus[\"default\"])((0, _symbolicUtils.convertListToOperatorChain)('times', leftCoefficients), (0, _symbolicUtils.convertListToOperatorChain)('times', rightCoefficients)), context);\n\n        if (newCoefficient.type !== 'number' || newCoefficient.value !== 0) {\n          results.push((0, _symbolicUtils.convertListToOperatorChain)('times', [newCoefficient].concat(_toConsumableArray(rightFactorsWithoutCoefficients))));\n        }\n\n        replaced.push(i);\n        replaced.push(j);\n      }\n    }\n\n    if (!replaced.includes(i)) {\n      results.push(summands[i]);\n    }\n  }\n\n  if (results.length === 0) {\n    return (0, _NumberNode[\"default\"])(0);\n  }\n\n  return (0, _symbolicUtils.convertListToOperatorChain)('plus', results);\n};\n\nfunction getCoefficients(factors) {\n  var coefficients = factors.filter(function (factor) {\n    return factor.type === 'number';\n  });\n  return coefficients.length === 0 ? [(0, _NumberNode[\"default\"])(1)] : coefficients;\n}\n\nfunction getFactprsWotjpitCoefficients(factors) {\n  var factorsWithoutCoefficients = factors.filter(function (factor) {\n    return factor.type !== 'number';\n  });\n  return factorsWithoutCoefficients.length === 0 ? [(0, _NumberNode[\"default\"])(1)] : factorsWithoutCoefficients;\n}\n\nfunction factorsEquals(leftFactors, rightFactors) {\n  if (leftFactors.length !== rightFactors.length) {\n    return false;\n  }\n\n  var alreadyMatched = [];\n\n  for (var i = 0; i < leftFactors.length; i++) {\n    var matched = false;\n\n    for (var j = 0; j < rightFactors.length; j++) {\n      if (alreadyMatched.includes(j)) {\n        continue;\n      }\n\n      if ((0, _equals[\"default\"])(leftFactors[i], rightFactors[j])) {\n        matched = true;\n        alreadyMatched.push(j);\n      }\n    }\n\n    if (!matched) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nvar normalizePlus = (0, _normalizeUtils.combineNormalizers)([evaluateIfPossible, normalizeChildren, rotateIfLeftChildPlus, combineLeftChildWithRightChildLeftChild, moveVariablesRight, combineMultiples]);\nvar _default = normalizePlus;\nexports[\"default\"] = _default;","map":{"version":3,"mappings":"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","names":["evaluateIfPossible","node","context","normalizeChildren","type","left","right","rotateIfLeftChildPlus","rotatedNode","combineLeftChildWithRightChildLeftChild","normalizedNode","moveVariablesRight","combineMultiples","summands","length","results","replaced","i","includes","leftFactors","leftCoefficients","getCoefficients","leftFactorsWithoutCoefficients","getFactprsWotjpitCoefficients","j","rightFactors","rightCoefficients","rightFactorsWithoutCoefficients","factorsEquals","newCoefficient","value","push","factors","coefficients","filter","factor","factorsWithoutCoefficients","alreadyMatched","matched","normalizePlus"],"sources":["/home/behrenle/Projects/private/arithmico-calculator/node_modules/@behrenle/number-cruncher/src/normalize/nodes/normalize-plus.ts"],"sourcesContent":["import { combineNormalizers, PartialNormalizer } from './../../utils/normalize-utils';\nimport normalize from '..';\nimport evaluate from '../../eval';\nimport createPlus from '../../create/Plus';\nimport { containsVariables, convertListToOperatorChain, convertOperatorChainToList } from '../../utils/symbolic-utils';\nimport { SyntaxTreeNode } from '../../types';\nimport createNumberNode from '../../create/NumberNode';\nimport equals from '../../equals/equals';\n\nconst evaluateIfPossible: PartialNormalizer = (node, context) => {\n    if (!containsVariables(node, context)) {\n        return evaluate(node, context);\n    }\n};\n\nconst normalizeChildren: PartialNormalizer = (node, context) => {\n    if (node.type !== 'plus') {\n        return;\n    }\n\n    return createPlus(normalize(node.left, context), normalize(node.right, context));\n};\n\nconst rotateIfLeftChildPlus: PartialNormalizer = (node, context) => {\n    if (!(node.type === 'plus' && node.left.type === 'plus')) {\n        return;\n    }\n\n    const rotatedNode = createPlus(node.left.left, createPlus(node.left.right, node.right));\n\n    return normalize(rotatedNode, context);\n};\n\nconst combineLeftChildWithRightChildLeftChild: PartialNormalizer = (node, context) => {\n    if (\n        !(\n            node.type === 'plus' &&\n            !containsVariables(node.left, context) &&\n            node.right.type === 'plus' &&\n            !containsVariables(node.right.left, context)\n        )\n    ) {\n        return;\n    }\n\n    const normalizedNode = createPlus(evaluate(createPlus(node.left, node.right.left), context), node.right.right);\n    return normalize(normalizedNode, context);\n};\n\nconst moveVariablesRight: PartialNormalizer = (node, context) => {\n    if (node.type !== 'plus') {\n        return;\n    }\n\n    if (node.right.type === 'plus') {\n        if (containsVariables(node.left, context) && !containsVariables(node.right.left, context)) {\n            return normalize(createPlus(node.right.left, createPlus(node.left, node.right.right)), context);\n        }\n    } else {\n        if (containsVariables(node.left, context) && !containsVariables(node.right, context)) {\n            return normalize(createPlus(node.right, node.left), context);\n        }\n    }\n};\n\nconst combineMultiples: PartialNormalizer = (node, context) => {\n    const summands = convertOperatorChainToList('plus', node);\n\n    if (summands.length < 2) {\n        return;\n    }\n\n    const results: SyntaxTreeNode[] = [];\n    const replaced: number[] = [];\n\n    for (let i = 0; i < summands.length; i++) {\n        if (replaced.includes(i)) {\n            continue;\n        }\n\n        const leftFactors = convertOperatorChainToList('times', summands[i]);\n        const leftCoefficients = getCoefficients(leftFactors);\n        const leftFactorsWithoutCoefficients = getFactprsWotjpitCoefficients(leftFactors);\n\n        for (let j = i + 1; j < summands.length; j++) {\n            if (replaced.includes(j)) {\n                continue;\n            }\n\n            const rightFactors = convertOperatorChainToList('times', summands[j]);\n            const rightCoefficients = getCoefficients(rightFactors);\n            const rightFactorsWithoutCoefficients = getFactprsWotjpitCoefficients(rightFactors);\n\n            if (factorsEquals(leftFactorsWithoutCoefficients, rightFactorsWithoutCoefficients)) {\n                const newCoefficient = normalize(\n                    createPlus(\n                        convertListToOperatorChain('times', leftCoefficients),\n                        convertListToOperatorChain('times', rightCoefficients),\n                    ),\n                    context,\n                );\n\n                if (newCoefficient.type !== 'number' || newCoefficient.value !== 0) {\n                    results.push(\n                        convertListToOperatorChain('times', [newCoefficient, ...rightFactorsWithoutCoefficients]),\n                    );\n                }\n\n                replaced.push(i);\n                replaced.push(j);\n            }\n        }\n\n        if (!replaced.includes(i)) {\n            results.push(summands[i]);\n        }\n    }\n\n    if (results.length === 0) {\n        return createNumberNode(0);\n    }\n\n    return convertListToOperatorChain('plus', results);\n};\n\nfunction getCoefficients(factors: SyntaxTreeNode[]) {\n    const coefficients = factors.filter((factor) => factor.type === 'number');\n    return coefficients.length === 0 ? [createNumberNode(1)] : coefficients;\n}\n\nfunction getFactprsWotjpitCoefficients(factors: SyntaxTreeNode[]) {\n    const factorsWithoutCoefficients = factors.filter((factor) => factor.type !== 'number');\n    return factorsWithoutCoefficients.length === 0 ? [createNumberNode(1)] : factorsWithoutCoefficients;\n}\n\nfunction factorsEquals(leftFactors: SyntaxTreeNode[], rightFactors: SyntaxTreeNode[]): boolean {\n    if (leftFactors.length !== rightFactors.length) {\n        return false;\n    }\n\n    const alreadyMatched: number[] = [];\n\n    for (let i = 0; i < leftFactors.length; i++) {\n        let matched = false;\n\n        for (let j = 0; j < rightFactors.length; j++) {\n            if (alreadyMatched.includes(j)) {\n                continue;\n            }\n\n            if (equals(leftFactors[i], rightFactors[j])) {\n                matched = true;\n                alreadyMatched.push(j);\n            }\n        }\n\n        if (!matched) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nconst normalizePlus = combineNormalizers([\n    evaluateIfPossible,\n    normalizeChildren,\n    rotateIfLeftChildPlus,\n    combineLeftChildWithRightChildLeftChild,\n    moveVariablesRight,\n    combineMultiples,\n]);\n\nexport default normalizePlus;\n"]},"metadata":{},"sourceType":"script"}