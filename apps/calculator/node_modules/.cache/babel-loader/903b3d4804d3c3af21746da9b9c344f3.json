{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _ = _interopRequireDefault(require(\"..\"));\n\nvar _Divided = _interopRequireDefault(require(\"../../create/Divided\"));\n\nvar _Negate = _interopRequireDefault(require(\"../../create/Negate\"));\n\nvar _NumberNode = _interopRequireDefault(require(\"../../create/NumberNode\"));\n\nvar _Plus = _interopRequireDefault(require(\"../../create/Plus\"));\n\nvar _Power = _interopRequireDefault(require(\"../../create/Power\"));\n\nvar _Times = _interopRequireDefault(require(\"../../create/Times\"));\n\nvar _eval = _interopRequireDefault(require(\"../../eval\"));\n\nvar _normalizeUtils = require(\"../../utils/normalize-utils\");\n\nvar _symbolicUtils = require(\"../../utils/symbolic-utils\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nvar evaluateIfPossible = function evaluateIfPossible(node, context) {\n  if (!(0, _symbolicUtils.containsVariables)(node, context)) {\n    return (0, _eval[\"default\"])(node, context);\n  }\n};\n\nvar normalizeChildren = function normalizeChildren(node, context) {\n  if (node.type !== 'divided') {\n    return;\n  }\n\n  return (0, _Divided[\"default\"])((0, _[\"default\"])(node.left, context), (0, _[\"default\"])(node.right, context));\n};\n\nvar distributeLeftChildPlus = function distributeLeftChildPlus(node, context) {\n  if (node.type !== 'divided' || node.left.type !== 'plus') {\n    return;\n  }\n\n  return (0, _[\"default\"])((0, _Plus[\"default\"])((0, _Divided[\"default\"])(node.left.left, node.right), (0, _Divided[\"default\"])(node.left.right, node.right)), context);\n};\n\nvar flipRightChildDivided = function flipRightChildDivided(node, context) {\n  if (node.type !== 'divided' || node.right.type !== 'divided') {\n    return;\n  }\n\n  return (0, _[\"default\"])((0, _Times[\"default\"])(node.left, (0, _Divided[\"default\"])(node.right.right, node.right.left)), context);\n};\n\nvar moveLeftNegateOut = function moveLeftNegateOut(node, context) {\n  if (node.type !== 'divided' || node.left.type !== 'negate') {\n    return;\n  }\n\n  return (0, _[\"default\"])((0, _Negate[\"default\"])((0, _Divided[\"default\"])(node.left.value, node.right)), context);\n};\n\nvar moveRightNegateOut = function moveRightNegateOut(node, context) {\n  if (node.type !== 'divided' || node.right.type !== 'negate') {\n    return;\n  }\n\n  return (0, _[\"default\"])((0, _Negate[\"default\"])((0, _Divided[\"default\"])(node.left, node.right.value)), context);\n};\n\nvar splitTimesDenominator = function splitTimesDenominator(node, context) {\n  if (node.type !== 'divided' || node.right.type !== 'times') {\n    return;\n  }\n\n  return (0, _[\"default\"])((0, _Times[\"default\"])((0, _Divided[\"default\"])(node.left, node.right.left), (0, _Divided[\"default\"])((0, _NumberNode[\"default\"])(1), node.right.right)), context);\n};\n\nvar convertSymbolDenominatorToPower = function convertSymbolDenominatorToPower(node, context) {\n  if (node.type !== 'divided' || node.right.type !== 'symbol') {\n    return;\n  }\n\n  return (0, _[\"default\"])((0, _Times[\"default\"])(node.left, (0, _Power[\"default\"])(node.right, (0, _NumberNode[\"default\"])(-1))), context);\n};\n\nvar negatePowerDenominatorAndMoveToNumerator = function negatePowerDenominatorAndMoveToNumerator(node, context) {\n  if (node.type !== 'divided' || node.right.type !== 'power') {\n    return;\n  }\n\n  return (0, _[\"default\"])((0, _Times[\"default\"])(node.left, (0, _Power[\"default\"])(node.right.left, (0, _Negate[\"default\"])(node.right.right))), context);\n};\n\nvar normalizeDivided = (0, _normalizeUtils.combineNormalizers)([evaluateIfPossible, flipRightChildDivided, normalizeChildren, distributeLeftChildPlus, moveLeftNegateOut, moveRightNegateOut, splitTimesDenominator, convertSymbolDenominatorToPower, negatePowerDenominatorAndMoveToNumerator]);\nvar _default = normalizeDivided;\nexports[\"default\"] = _default;","map":{"version":3,"mappings":"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","names":["evaluateIfPossible","node","context","normalizeChildren","type","left","right","distributeLeftChildPlus","flipRightChildDivided","moveLeftNegateOut","value","moveRightNegateOut","splitTimesDenominator","convertSymbolDenominatorToPower","negatePowerDenominatorAndMoveToNumerator","normalizeDivided"],"sources":["/home/behrenle/Projects/private/arithmico-calculator/node_modules/@behrenle/number-cruncher/src/normalize/nodes/normalize-divided.ts"],"sourcesContent":["import normalize from '..';\nimport createDivided from '../../create/Divided';\nimport createNegate from '../../create/Negate';\nimport createNumberNode from '../../create/NumberNode';\nimport createPlus from '../../create/Plus';\nimport createPower from '../../create/Power';\nimport createTimes from '../../create/Times';\nimport evaluate from '../../eval';\nimport { combineNormalizers, PartialNormalizer } from '../../utils/normalize-utils';\nimport { containsVariables } from '../../utils/symbolic-utils';\n\nconst evaluateIfPossible: PartialNormalizer = (node, context) => {\n    if (!containsVariables(node, context)) {\n        return evaluate(node, context);\n    }\n};\n\nconst normalizeChildren: PartialNormalizer = (node, context) => {\n    if (node.type !== 'divided') {\n        return;\n    }\n\n    return createDivided(normalize(node.left, context), normalize(node.right, context));\n};\n\nconst distributeLeftChildPlus: PartialNormalizer = (node, context) => {\n    if (node.type !== 'divided' || node.left.type !== 'plus') {\n        return;\n    }\n\n    return normalize(\n        createPlus(createDivided(node.left.left, node.right), createDivided(node.left.right, node.right)),\n        context,\n    );\n};\n\nconst flipRightChildDivided: PartialNormalizer = (node, context) => {\n    if (node.type !== 'divided' || node.right.type !== 'divided') {\n        return;\n    }\n\n    return normalize(createTimes(node.left, createDivided(node.right.right, node.right.left)), context);\n};\n\nconst moveLeftNegateOut: PartialNormalizer = (node, context) => {\n    if (node.type !== 'divided' || node.left.type !== 'negate') {\n        return;\n    }\n\n    return normalize(createNegate(createDivided(node.left.value, node.right)), context);\n};\n\nconst moveRightNegateOut: PartialNormalizer = (node, context) => {\n    if (node.type !== 'divided' || node.right.type !== 'negate') {\n        return;\n    }\n\n    return normalize(createNegate(createDivided(node.left, node.right.value)), context);\n};\n\nconst splitTimesDenominator: PartialNormalizer = (node, context) => {\n    if (node.type !== 'divided' || node.right.type !== 'times') {\n        return;\n    }\n\n    return normalize(\n        createTimes(createDivided(node.left, node.right.left), createDivided(createNumberNode(1), node.right.right)),\n        context,\n    );\n};\n\nconst convertSymbolDenominatorToPower: PartialNormalizer = (node, context) => {\n    if (node.type !== 'divided' || node.right.type !== 'symbol') {\n        return;\n    }\n\n    return normalize(createTimes(node.left, createPower(node.right, createNumberNode(-1))), context);\n};\n\nconst negatePowerDenominatorAndMoveToNumerator: PartialNormalizer = (node, context) => {\n    if (node.type !== 'divided' || node.right.type !== 'power') {\n        return;\n    }\n\n    return normalize(createTimes(node.left, createPower(node.right.left, createNegate(node.right.right))), context);\n};\n\nconst normalizeDivided = combineNormalizers([\n    evaluateIfPossible,\n    flipRightChildDivided,\n    normalizeChildren,\n    distributeLeftChildPlus,\n    moveLeftNegateOut,\n    moveRightNegateOut,\n    splitTimesDenominator,\n    convertSymbolDenominatorToPower,\n    negatePowerDenominatorAndMoveToNumerator,\n]);\n\nexport default normalizeDivided;\n"]},"metadata":{},"sourceType":"script"}