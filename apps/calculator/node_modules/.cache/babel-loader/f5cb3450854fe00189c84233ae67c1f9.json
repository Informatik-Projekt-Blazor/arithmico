{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _FunctionCall = _interopRequireDefault(require(\"../../../create/FunctionCall\"));\n\nvar _Minus = _interopRequireDefault(require(\"../../../create/Minus\"));\n\nvar _NumberNode = _interopRequireDefault(require(\"../../../create/NumberNode\"));\n\nvar _SymbolNode = _interopRequireDefault(require(\"../../../create/SymbolNode\"));\n\nvar _Vector = _interopRequireDefault(require(\"../../../create/Vector\"));\n\nvar _parameterUtils = require(\"../../../utils/parameter-utils\");\n\nvar _pluginBuilder = require(\"../../../utils/plugin-builder\");\n\nvar _symbolicUtils = require(\"../../../utils/symbolic-utils\");\n\nvar _checkCandidates = _interopRequireDefault(require(\"./utils/check-candidates\"));\n\nvar _findCandidates = _interopRequireDefault(require(\"./utils/find-candidates\"));\n\nvar _findDirectHits = _interopRequireDefault(require(\"./utils/find-direct-hits\"));\n\nvar _scan = _interopRequireDefault(require(\"./utils/scan\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar nsolvePlugin = (0, _pluginBuilder.createPlugin)('core/nsolve');\n(0, _pluginBuilder.addPluginAuthor)(nsolvePlugin, 'core');\n(0, _pluginBuilder.addPluginDescription)(nsolvePlugin, 'adds nsolve function');\nvar nsolveHeader = [{\n  type: 'equals',\n  name: 'equation',\n  evaluate: false\n}, {\n  type: 'number',\n  name: 'start',\n  evaluate: true,\n  optional: true\n}, {\n  type: 'number',\n  name: 'stop',\n  evaluate: true,\n  optional: true\n}];\n(0, _pluginBuilder.addPluginFunction)(nsolvePlugin, {\n  name: 'nsolve',\n  \"function\": {\n    type: 'function',\n    header: nsolveHeader,\n    expression: (0, _FunctionCall[\"default\"])((0, _SymbolNode[\"default\"])('nsolve'), [(0, _SymbolNode[\"default\"])('equation'), (0, _SymbolNode[\"default\"])('start'), (0, _SymbolNode[\"default\"])('stop')]),\n    evaluator: function evaluator(parameters, context) {\n      var stackFrame = (0, _parameterUtils.mapParametersToStackFrame)('nsolve', parameters, nsolveHeader, context);\n      var leftLimit = stackFrame.start ? stackFrame.start.value : -20;\n      var rightLimit = stackFrame.stop ? stackFrame.stop.value : 20;\n      var equation = stackFrame.equation;\n      var expression = (0, _Minus[\"default\"])(equation.left, equation.right);\n      var variableNames = (0, _symbolicUtils.getVariableNames)(expression, context);\n\n      if (variableNames.length !== 1) {\n        throw \"RuntimeError: Invalid number of variables expected 1 got \".concat(variableNames.length);\n      }\n\n      var value = (0, _NumberNode[\"default\"])(leftLimit);\n\n      var localStackFrame = _defineProperty({}, variableNames[0], value);\n\n      var localContext = _objectSpread(_objectSpread({}, context), {}, {\n        stack: [].concat(_toConsumableArray(context.stack), [localStackFrame])\n      });\n\n      var points = (0, _scan[\"default\"])(expression, leftLimit, rightLimit, value, localContext);\n      var directHits = (0, _findDirectHits[\"default\"])(points);\n      var candidates = (0, _findCandidates[\"default\"])(points);\n      var solutions = (0, _checkCandidates[\"default\"])(expression, candidates, value, localContext);\n      var results = [];\n      [].concat(_toConsumableArray(directHits), _toConsumableArray(solutions)).forEach(function (solution) {\n        if (!results.includes(solution)) {\n          results.push(solution);\n        }\n      });\n      return (0, _Vector[\"default\"])(results.sort(function (a, b) {\n        return a - b;\n      }).map(function (solution) {\n        return (0, _NumberNode[\"default\"])(solution);\n      }));\n    }\n  },\n  documentation: {\n    en: {\n      synopsis: 'nsolve(equation, start=-20, stop=20)',\n      description: 'If possible, solve the equation within the limits.'\n    },\n    de: {\n      synopsis: 'nsolve(equation, start=-20, stop=20)',\n      description: 'Sucht nach Lösungen für die gegebene Gleichung in den Grenzen start und stop.'\n    }\n  }\n});\nvar _default = nsolvePlugin;\nexports[\"default\"] = _default;","map":{"version":3,"mappings":"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","names":["nsolvePlugin","nsolveHeader","type","name","evaluate","optional","header","expression","evaluator","parameters","context","stackFrame","leftLimit","start","value","rightLimit","stop","equation","left","right","variableNames","length","localStackFrame","localContext","stack","points","directHits","candidates","solutions","results","forEach","solution","includes","push","sort","a","b","map","documentation","en","synopsis","description","de"],"sources":["/home/behrenle/Projects/private/arithmico-calculator/node_modules/@behrenle/number-cruncher/src/plugins/core/nsolve/nsolve.ts"],"sourcesContent":["import createFunctionCall from '../../../create/FunctionCall';\nimport createMinus from '../../../create/Minus';\nimport createNumberNode from '../../../create/NumberNode';\nimport createSymbolNode from '../../../create/SymbolNode';\nimport createVector from '../../../create/Vector';\nimport { Context, Equals, NumberNode, SyntaxTreeNode } from '../../../types';\nimport { FunctionHeaderItem } from '../../../types/SyntaxTreeNodes';\nimport { mapParametersToStackFrame } from '../../../utils/parameter-utils';\nimport { addPluginAuthor, addPluginDescription, addPluginFunction, createPlugin } from '../../../utils/plugin-builder';\nimport { getVariableNames } from '../../../utils/symbolic-utils';\nimport checkCandidates from './utils/check-candidates';\nimport findCandidates from './utils/find-candidates';\nimport findDirectHits from './utils/find-direct-hits';\nimport scan from './utils/scan';\n\nconst nsolvePlugin = createPlugin('core/nsolve');\n\naddPluginAuthor(nsolvePlugin, 'core');\naddPluginDescription(nsolvePlugin, 'adds nsolve function');\n\nconst nsolveHeader: FunctionHeaderItem[] = [\n    { type: 'equals', name: 'equation', evaluate: false },\n    { type: 'number', name: 'start', evaluate: true, optional: true },\n    { type: 'number', name: 'stop', evaluate: true, optional: true },\n];\n\naddPluginFunction(nsolvePlugin, {\n    name: 'nsolve',\n    function: {\n        type: 'function',\n        header: nsolveHeader,\n        expression: createFunctionCall(createSymbolNode('nsolve'), [\n            createSymbolNode('equation'),\n            createSymbolNode('start'),\n            createSymbolNode('stop'),\n        ]),\n        evaluator: (parameters: SyntaxTreeNode[], context: Context): SyntaxTreeNode => {\n            const stackFrame = mapParametersToStackFrame('nsolve', parameters, nsolveHeader, context);\n            const leftLimit = stackFrame.start ? (<NumberNode>stackFrame.start).value : -20;\n            const rightLimit = stackFrame.stop ? (<NumberNode>stackFrame.stop).value : 20;\n            const equation = <Equals>stackFrame.equation;\n            const expression = createMinus(equation.left, equation.right);\n            const variableNames = getVariableNames(expression, context);\n\n            if (variableNames.length !== 1) {\n                throw `RuntimeError: Invalid number of variables expected 1 got ${variableNames.length}`;\n            }\n\n            const value = createNumberNode(leftLimit);\n            const localStackFrame = { [variableNames[0]]: value };\n            const localContext: Context = {\n                ...context,\n                stack: [...context.stack, localStackFrame],\n            };\n\n            const points = scan(expression, leftLimit, rightLimit, value, localContext);\n            const directHits = findDirectHits(points);\n            const candidates = findCandidates(points);\n            const solutions = checkCandidates(expression, candidates, value, localContext);\n\n            const results: number[] = [];\n            [...directHits, ...solutions].forEach((solution) => {\n                if (!results.includes(solution)) {\n                    results.push(solution);\n                }\n            });\n\n            return createVector(results.sort((a, b) => a - b).map((solution) => createNumberNode(solution)));\n        },\n    },\n    documentation: {\n        en: {\n            synopsis: 'nsolve(equation, start=-20, stop=20)',\n            description: 'If possible, solve the equation within the limits.',\n        },\n        de: {\n            synopsis: 'nsolve(equation, start=-20, stop=20)',\n            description: 'Sucht nach Lösungen für die gegebene Gleichung in den Grenzen start und stop.',\n        },\n    },\n});\n\nexport default nsolvePlugin;\n"]},"metadata":{},"sourceType":"script"}