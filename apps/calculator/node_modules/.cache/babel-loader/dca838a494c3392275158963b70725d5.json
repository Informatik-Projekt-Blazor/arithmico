{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = evaluateTimes;\n\nvar _2 = _interopRequireDefault(require(\"..\"));\n\nvar _NumberNode = _interopRequireDefault(require(\"../../create/NumberNode\"));\n\nvar _Plus = _interopRequireDefault(require(\"../../create/Plus\"));\n\nvar _Times = _interopRequireDefault(require(\"../../create/Times\"));\n\nvar _Vector = _interopRequireDefault(require(\"../../create/Vector\"));\n\nvar _composeFunctionUtils = require(\"../../utils/compose-function-utils\");\n\nvar _vectorUtils = require(\"../../utils/vector-utils\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction matrixTimesMatrixItem(leftMatrix, rightMatrix, x, y) {\n  var line = leftMatrix.values[y];\n  return line.values.map(function (_, index) {\n    return (0, _Times[\"default\"])((0, _vectorUtils.getVectorElement)(leftMatrix, [y, index]), (0, _vectorUtils.getVectorElement)(rightMatrix, [index, x]));\n  }).reduceRight(function (right, left) {\n    return (0, _Plus[\"default\"])(left, right);\n  });\n}\n\nfunction evaluateTimes(node, context) {\n  var leftChild = (0, _2[\"default\"])(node.left, context);\n  var rightChild = (0, _2[\"default\"])(node.right, context);\n\n  if (leftChild.type === 'number' && rightChild.type === 'number' && context.options.config.operators.timesNumberNumber) {\n    return (0, _NumberNode[\"default\"])(leftChild.value * rightChild.value);\n  }\n\n  if (leftChild.type === 'number' && rightChild.type === 'vector' && context.options.config.operators.timesNumberVector) {\n    return (0, _Vector[\"default\"])(rightChild.values.map(function (value) {\n      return (0, _2[\"default\"])((0, _Times[\"default\"])(leftChild, value), context);\n    }));\n  }\n\n  if (leftChild.type === 'vector' && rightChild.type === 'number' && context.options.config.operators.timesNumberVector) {\n    return (0, _Vector[\"default\"])(leftChild.values.map(function (value) {\n      return (0, _2[\"default\"])((0, _Times[\"default\"])(rightChild, value), context);\n    }));\n  }\n\n  if (leftChild.type === 'vector' && rightChild.type === 'vector') {\n    var leftDims = (0, _vectorUtils.getVectorDimensions)(leftChild);\n    var rightDims = (0, _vectorUtils.getVectorDimensions)(rightChild);\n    var leftRank = leftDims.length;\n    var rightRank = rightDims.length; // vector scalar product\n\n    if (leftRank === 1 && rightRank === 1 && context.options.config.operators.timesVectorVector) {\n      if (leftDims[0] !== rightDims[0]) {\n        throw 'ShapeError: incompatible vector shapes';\n      }\n\n      if (leftDims[0] === 0) {\n        throw 'ShapeError: empty vector';\n      }\n\n      var components = leftChild.values.map(function (_, index) {\n        return (0, _Times[\"default\"])(leftChild.values[index], rightChild.values[index]);\n      });\n      return (0, _2[\"default\"])(components.reduceRight(function (right, left) {\n        return (0, _Plus[\"default\"])(left, right);\n      }), context);\n    } else if (leftRank === 2 && rightRank === 2 && context.options.config.operators.timesMatrixMatrix) {\n      if (leftDims[1] !== rightDims[0]) {\n        throw 'ShapeError: incompatible vector shapes';\n      }\n\n      var lines = [];\n\n      for (var y = 0; y < leftDims[0]; y++) {\n        var lineElements = [];\n\n        for (var x = 0; x < rightDims[1]; x++) {\n          lineElements.push(matrixTimesMatrixItem(leftChild, rightChild, x, y));\n        }\n\n        lines.push((0, _Vector[\"default\"])(lineElements));\n      }\n\n      return (0, _2[\"default\"])((0, _Vector[\"default\"])(lines), context);\n    } else if (leftRank === 2 && rightRank === 1 && context.options.config.operators.timesVectorMatrix) {\n      if (leftDims[1] !== rightDims[0]) {\n        throw 'ShapeError: incompatible vector shapes';\n      }\n\n      var result = (0, _2[\"default\"])((0, _Times[\"default\"])(leftChild, (0, _Vector[\"default\"])(rightChild.values.map(function (value) {\n        return (0, _Vector[\"default\"])([value]);\n      }))), context);\n      return (0, _Vector[\"default\"])(result.values.map(function (vector) {\n        return vector.values[0];\n      }));\n    } else if (leftRank === 1 && rightRank === 2 && context.options.config.operators.timesVectorMatrix) {\n      if (leftDims[0] !== rightDims[0]) {\n        throw 'ShapeError: incompatible vector shapes';\n      }\n\n      return (0, _2[\"default\"])((0, _Times[\"default\"])((0, _Vector[\"default\"])([leftChild]), rightChild), context).values[0];\n    }\n\n    throw 'ShapeError: incompatible vector shapes';\n  } else if (leftChild.type === 'function' && rightChild.type === 'function') {\n    return (0, _composeFunctionUtils.createBinaryOperatorFunctionComposition)(leftChild, rightChild, _Times[\"default\"], context);\n  }\n\n  throw \"TypeError: <\".concat(leftChild.type, \"> * <\").concat(rightChild.type, \"> is not defined\");\n}","map":{"version":3,"mappings":"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","names":["matrixTimesMatrixItem","leftMatrix","rightMatrix","x","y","line","values","map","_","index","reduceRight","right","left","evaluateTimes","node","context","leftChild","rightChild","type","options","config","operators","timesNumberNumber","value","timesNumberVector","leftDims","rightDims","leftRank","length","rightRank","timesVectorVector","components","timesMatrixMatrix","lines","lineElements","push","timesVectorMatrix","result","vector","createTimes"],"sources":["/home/behrenle/Projects/private/arithmico-calculator/node_modules/@behrenle/number-cruncher/src/eval/nodes/Times.ts"],"sourcesContent":["import evaluate from '..';\nimport createNumberNode from '../../create/NumberNode';\nimport createPlus from '../../create/Plus';\nimport createTimes from '../../create/Times';\nimport createVector from '../../create/Vector';\nimport { Times, Context, SyntaxTreeNode, Vector } from '../../types';\nimport { createBinaryOperatorFunctionComposition } from '../../utils/compose-function-utils';\nimport { getVectorDimensions, getVectorElement } from '../../utils/vector-utils';\n\nfunction matrixTimesMatrixItem(leftMatrix: Vector, rightMatrix: Vector, x: number, y: number): SyntaxTreeNode {\n    const line = leftMatrix.values[y] as Vector;\n    return line.values\n        .map(\n            (_, index) =>\n                createTimes(\n                    getVectorElement(leftMatrix, [y, index]),\n                    getVectorElement(rightMatrix, [index, x]),\n                ) as SyntaxTreeNode,\n        )\n        .reduceRight((right, left) => createPlus(left, right));\n}\n\nexport default function evaluateTimes(node: Times, context: Context): SyntaxTreeNode {\n    const leftChild = evaluate(node.left, context);\n    const rightChild = evaluate(node.right, context);\n\n    if (\n        leftChild.type === 'number' &&\n        rightChild.type === 'number' &&\n        context.options.config.operators.timesNumberNumber\n    ) {\n        return createNumberNode(leftChild.value * rightChild.value);\n    }\n\n    if (\n        leftChild.type === 'number' &&\n        rightChild.type === 'vector' &&\n        context.options.config.operators.timesNumberVector\n    ) {\n        return createVector(rightChild.values.map((value) => evaluate(createTimes(leftChild, value), context)));\n    }\n\n    if (\n        leftChild.type === 'vector' &&\n        rightChild.type === 'number' &&\n        context.options.config.operators.timesNumberVector\n    ) {\n        return createVector(leftChild.values.map((value) => evaluate(createTimes(rightChild, value), context)));\n    }\n\n    if (leftChild.type === 'vector' && rightChild.type === 'vector') {\n        const leftDims = getVectorDimensions(leftChild);\n        const rightDims = getVectorDimensions(rightChild);\n        const leftRank = leftDims.length;\n        const rightRank = rightDims.length;\n\n        // vector scalar product\n        if (leftRank === 1 && rightRank === 1 && context.options.config.operators.timesVectorVector) {\n            if (leftDims[0] !== rightDims[0]) {\n                throw 'ShapeError: incompatible vector shapes';\n            }\n\n            if (leftDims[0] === 0) {\n                throw 'ShapeError: empty vector';\n            }\n\n            const components: SyntaxTreeNode[] = leftChild.values.map((_, index) =>\n                createTimes(leftChild.values[index], rightChild.values[index]),\n            );\n\n            return evaluate(\n                components.reduceRight((right, left) => createPlus(left, right)),\n                context,\n            );\n        } else if (leftRank === 2 && rightRank === 2 && context.options.config.operators.timesMatrixMatrix) {\n            if (leftDims[1] !== rightDims[0]) {\n                throw 'ShapeError: incompatible vector shapes';\n            }\n\n            const lines: Vector[] = [];\n\n            for (let y = 0; y < leftDims[0]; y++) {\n                const lineElements: SyntaxTreeNode[] = [];\n                for (let x = 0; x < rightDims[1]; x++) {\n                    lineElements.push(matrixTimesMatrixItem(leftChild, rightChild, x, y));\n                }\n                lines.push(createVector(lineElements));\n            }\n\n            return evaluate(createVector(lines), context);\n        } else if (leftRank === 2 && rightRank === 1 && context.options.config.operators.timesVectorMatrix) {\n            if (leftDims[1] !== rightDims[0]) {\n                throw 'ShapeError: incompatible vector shapes';\n            }\n\n            const result = evaluate(\n                createTimes(leftChild, createVector(rightChild.values.map((value) => createVector([value])))),\n                context,\n            ) as Vector;\n\n            return createVector(result.values.map((vector: Vector) => vector.values[0]));\n        } else if (leftRank === 1 && rightRank === 2 && context.options.config.operators.timesVectorMatrix) {\n            if (leftDims[0] !== rightDims[0]) {\n                throw 'ShapeError: incompatible vector shapes';\n            }\n\n            return (evaluate(createTimes(createVector([leftChild]), rightChild), context) as Vector).values[0];\n        }\n\n        throw 'ShapeError: incompatible vector shapes';\n    } else if (leftChild.type === 'function' && rightChild.type === 'function') {\n        return createBinaryOperatorFunctionComposition(leftChild, rightChild, createTimes, context);\n    }\n\n    throw `TypeError: <${leftChild.type}> * <${rightChild.type}> is not defined`;\n}\n"]},"metadata":{},"sourceType":"script"}