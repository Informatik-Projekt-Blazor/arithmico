{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mapParametersToStackFrame = mapParametersToStackFrame;\nexports.compareFunctionHeaders = compareFunctionHeaders;\n\nvar _eval = _interopRequireDefault(require(\"../eval\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction mapParametersToStackFrame(name, parameters, header, context) {\n  var stackFrame = {};\n  var parameterIndex = 0;\n  var matched = 0;\n\n  var _iterator = _createForOfIteratorHelper(header),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var headerItem = _step.value;\n      matched = 0;\n\n      if (!headerItem.optional && parameters.slice(parameterIndex).length === 0) {\n        throw \"TypeError: \".concat(name, \": argument #\").concat(parameterIndex + 1, \": invalid number of arguments expected \").concat(headerItem.type, \" got nothing\");\n      }\n\n      var _iterator2 = _createForOfIteratorHelper(parameters.slice(parameterIndex)),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var parameter = _step2.value;\n          var evaluatedParameter = void 0;\n\n          if (headerItem.evaluate) {\n            evaluatedParameter = (0, _eval[\"default\"])(parameter, context);\n          }\n\n          if (!headerItem.evaluate && parameter.type === headerItem.type || headerItem.evaluate && evaluatedParameter.type === headerItem.type || headerItem.type === 'any') {\n            parameterIndex++;\n\n            if (headerItem.repeat) {\n              stackFrame[\"\".concat(headerItem.name, \"_\").concat(matched)] = headerItem.evaluate ? evaluatedParameter : parameter;\n              matched++;\n            } else {\n              stackFrame[headerItem.name] = headerItem.evaluate ? evaluatedParameter : parameter;\n              break;\n            }\n          } else {\n            if (headerItem.repeat && matched) {\n              break;\n            }\n\n            if (headerItem.optional) {\n              break;\n            }\n\n            throw \"TypeError: \".concat(name, \": argument #\").concat(parameterIndex + 1, \": expected \").concat(headerItem.type, \" got \").concat(parameter.type);\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (parameterIndex !== parameters.length) {\n    throw \"TypeError: \".concat(name, \": argument #\").concat(parameterIndex + 1, \": invalid number of arguments expected nothing got \").concat(parameters[parameterIndex].type);\n  }\n\n  return stackFrame;\n}\n\nfunction compareFunctionHeaders(headerA, headerB) {\n  if (headerA.length !== headerB.length) return false;\n  return headerA.every(function (_, index) {\n    return headerA[index].type === headerB[index].type && headerA[index].repeat === headerB[index].repeat && headerA[index].optional === headerB[index].optional;\n  });\n}","map":{"version":3,"mappings":"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","names":["mapParametersToStackFrame","name","parameters","header","context","stackFrame","parameterIndex","matched","headerItem","optional","slice","length","type","parameter","evaluatedParameter","evaluate","repeat","_iterator2","_iterator","compareFunctionHeaders","headerA","headerB","every","_","index"],"sources":["/home/behrenle/Projects/private/arithmico-calculator/node_modules/@behrenle/number-cruncher/src/utils/parameter-utils.ts"],"sourcesContent":["import { Context, StackFrame } from './../types/Context';\nimport { SyntaxTreeNode, FunctionHeaderItem } from '../types/SyntaxTreeNodes';\nimport evaluate from '../eval';\n\nexport function mapParametersToStackFrame(\n    name: string,\n    parameters: SyntaxTreeNode[],\n    header: FunctionHeaderItem[],\n    context: Context,\n): StackFrame {\n    const stackFrame: StackFrame = {};\n    let parameterIndex = 0;\n    let matched = 0;\n\n    for (const headerItem of header) {\n        matched = 0;\n\n        if (!headerItem.optional && parameters.slice(parameterIndex).length === 0) {\n            throw `TypeError: ${name}: argument #${parameterIndex + 1}: invalid number of arguments expected ${\n                headerItem.type\n            } got nothing`;\n        }\n\n        for (const parameter of parameters.slice(parameterIndex)) {\n            let evaluatedParameter;\n            if (headerItem.evaluate) {\n                evaluatedParameter = evaluate(parameter, context);\n            }\n\n            if (\n                (!headerItem.evaluate && parameter.type === headerItem.type) ||\n                (headerItem.evaluate && evaluatedParameter.type === headerItem.type) ||\n                headerItem.type === 'any'\n            ) {\n                parameterIndex++;\n                if (headerItem.repeat) {\n                    stackFrame[`${headerItem.name}_${matched}`] = headerItem.evaluate ? evaluatedParameter : parameter;\n                    matched++;\n                } else {\n                    stackFrame[headerItem.name] = headerItem.evaluate ? evaluatedParameter : parameter;\n                    break;\n                }\n            } else {\n                if (headerItem.repeat && matched) {\n                    break;\n                }\n                if (headerItem.optional) {\n                    break;\n                }\n                throw `TypeError: ${name}: argument #${parameterIndex + 1}: expected ${headerItem.type} got ${\n                    parameter.type\n                }`;\n            }\n        }\n    }\n\n    if (parameterIndex !== parameters.length) {\n        throw `TypeError: ${name}: argument #${parameterIndex + 1}: invalid number of arguments expected nothing got ${\n            parameters[parameterIndex].type\n        }`;\n    }\n\n    return stackFrame;\n}\n\nexport function compareFunctionHeaders(headerA: FunctionHeaderItem[], headerB: FunctionHeaderItem[]): boolean {\n    if (headerA.length !== headerB.length) return false;\n\n    return headerA.every(\n        (_, index) =>\n            headerA[index].type === headerB[index].type &&\n            headerA[index].repeat === headerB[index].repeat &&\n            headerA[index].optional === headerB[index].optional,\n    );\n}\n"]},"metadata":{},"sourceType":"script"}