{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _Equals = _interopRequireDefault(require(\"../../../create/Equals\"));\n\nvar _FunctionCall = _interopRequireDefault(require(\"../../../create/FunctionCall\"));\n\nvar _NumberNode = _interopRequireDefault(require(\"../../../create/NumberNode\"));\n\nvar _SymbolNode = _interopRequireDefault(require(\"../../../create/SymbolNode\"));\n\nvar _Vector = _interopRequireDefault(require(\"../../../create/Vector\"));\n\nvar _normalize = _interopRequireDefault(require(\"../../../normalize\"));\n\nvar _serialize = _interopRequireDefault(require(\"../../../serialize\"));\n\nvar _pluginBuilder = require(\"../../../utils/plugin-builder\");\n\nvar _calculateDet = require(\"./utils/calculate-det\");\n\nvar _checkLinear = require(\"./utils/check-linear\");\n\nvar _getCoefficients = require(\"./utils/get-coefficients\");\n\nvar _matrixUtils = require(\"./utils/matrix-utils\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nvar lsolvePlugin = (0, _pluginBuilder.createPlugin)('lsolve');\n(0, _pluginBuilder.addPluginAuthor)(lsolvePlugin, 'core');\n(0, _pluginBuilder.addPluginDescription)(lsolvePlugin, 'adds lsolve function');\nvar lsolveHeader = [{\n  type: 'equals',\n  name: 'equation',\n  evaluate: false,\n  repeat: true\n}];\n(0, _pluginBuilder.addPluginFunction)(lsolvePlugin, {\n  name: 'lsolve',\n  documentation: {\n    en: {\n      synopsis: 'lsolve(equation, ...)',\n      description: 'If possible, solve the set of linear equations.'\n    },\n    de: {\n      synopsis: 'lsolve(equation, ...)',\n      description: 'Löst, falls möglich, das lineare Gleichungssystem.'\n    }\n  },\n  \"function\": {\n    type: 'function',\n    header: lsolveHeader,\n    expression: (0, _FunctionCall[\"default\"])((0, _SymbolNode[\"default\"])('lsolve'), [(0, _SymbolNode[\"default\"])('equation+')]),\n    evaluator: function evaluator(parameters, context) {\n      var equations = [];\n\n      try {\n        parameters.map(function (parameter) {\n          return (0, _normalize[\"default\"])(parameter, context);\n        }).forEach(function (normalizedParameter) {\n          if (normalizedParameter.type !== 'equals') {\n            throw '';\n          }\n\n          equations.push(normalizedParameter);\n        });\n      } catch (_error) {\n        throw 'lsolve: invalid equation(s)';\n      }\n\n      equations.forEach(function (equation) {\n        if (!(0, _checkLinear.isEquationLinear)(equation, context)) {\n          throw \"lsolve: \\\"\".concat((0, _serialize[\"default\"])(equation, context.options), \"\\\" is not linear\");\n        }\n      });\n      var variableNames = (0, _getCoefficients.getVariableNamesFromEquations)(equations, context);\n\n      if (variableNames.length !== equations.length) {\n        throw 'RuntimeError: lsolve: invalid number of variables';\n      }\n\n      var coefficients = (0, _getCoefficients.getCoefficientMatrix)(equations, context);\n      var constants = (0, _getCoefficients.getConstantVector)(equations);\n      var results = [];\n      var coefficientsDet = (0, _calculateDet.det)(coefficients);\n\n      if (coefficientsDet === 0) {\n        throw 'SolveError: The equation system has no solution';\n      }\n\n      for (var i = 0; i < variableNames.length; i++) {\n        var value = (0, _calculateDet.det)((0, _matrixUtils.replaceColumn)(coefficients, constants, i)) / coefficientsDet;\n        results.push((0, _Equals[\"default\"])((0, _SymbolNode[\"default\"])(variableNames[i]), (0, _NumberNode[\"default\"])(value)));\n      }\n\n      return (0, _Vector[\"default\"])(results);\n    }\n  }\n});\nvar _default = lsolvePlugin;\nexports[\"default\"] = _default;","map":{"version":3,"mappings":";;;;;;;AAAA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;;AACA;;AACA;;AACA;;AACA;;;;;;;;AAEA,IAAMA,YAAY,GAAG,iCAAa,QAAb,CAArB;AAEA,oCAAgBA,YAAhB,EAA8B,MAA9B;AACA,yCAAqBA,YAArB,EAAmC,sBAAnC;AAEA,IAAMC,YAAkC,GAAG,CAAC;EAAEC,IAAI,EAAE,QAAR;EAAkBC,IAAI,EAAE,UAAxB;EAAoCC,QAAQ,EAAE,KAA9C;EAAqDC,MAAM,EAAE;AAA7D,CAAD,CAA3C;AAEA,sCAAkBL,YAAlB,EAAgC;EAC5BG,IAAI,EAAE,QADsB;EAE5BG,aAAa,EAAE;IACXC,EAAE,EAAE;MACAC,QAAQ,EAAE,uBADV;MAEAC,WAAW,EAAE;IAFb,CADO;IAKXC,EAAE,EAAE;MACAF,QAAQ,EAAE,uBADV;MAEAC,WAAW,EAAE;IAFb;EALO,CAFa;EAY5B,YAAU;IACNP,IAAI,EAAE,UADA;IAENS,MAAM,EAAEV,YAFF;IAGNW,UAAU,EAAE,8BAAmB,4BAAiB,QAAjB,CAAnB,EAA+C,CAAC,4BAAiB,WAAjB,CAAD,CAA/C,CAHN;IAINC,SAAS,EAAE,mBAACC,UAAD,EAAaC,OAAb,EAAyB;MAChC,IAAMC,SAAmB,GAAG,EAA5B;;MACA,IAAI;QACAF,UAAU,CACLG,GADLH,CACS,UAACI,SAAD;UAAA,OAAe,2BAAUA,SAAV,EAAqBH,OAArB,CAAf;QADT,GAEKI,OAFLL,CAEa,UAACM,mBAAD,EAAyB;UAC9B,IAAIA,mBAAmB,CAAClB,IAApBkB,KAA6B,QAAjC,EAA2C;YACvC,MAAM,EAAN;UACH;;UACDJ,SAAS,CAACK,IAAVL,CAAeI,mBAAfJ;QANR;MADJ,EASE,OAAOM,MAAP,EAAe;QACb,MAAM,6BAAN;MACH;;MAEDN,SAAS,CAACG,OAAVH,CAAkB,UAACO,QAAD,EAAc;QAC5B,IAAI,CAAC,mCAAiBA,QAAjB,EAA2BR,OAA3B,CAAL,EAA0C;UACtC,0BAAkB,2BAAUQ,QAAV,EAAoBR,OAAO,CAACS,OAA5B,CAAlB;QACH;MAHL;MAMA,IAAMC,aAAa,GAAG,oDAA8BT,SAA9B,EAAyCD,OAAzC,CAAtB;;MAEA,IAAIU,aAAa,CAACC,MAAdD,KAAyBT,SAAS,CAACU,MAAvC,EAA+C;QAC3C,MAAM,mDAAN;MACH;;MAED,IAAMC,YAAY,GAAG,2CAAqBX,SAArB,EAAgCD,OAAhC,CAArB;MACA,IAAMa,SAAS,GAAG,wCAAkBZ,SAAlB,CAAlB;MACA,IAAMa,OAAiB,GAAG,EAA1B;MACA,IAAMC,eAAe,GAAG,uBAAIH,YAAJ,CAAxB;;MAEA,IAAIG,eAAe,KAAK,CAAxB,EAA2B;QACvB,MAAM,iDAAN;MACH;;MAED,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,aAAa,CAACC,MAAlC,EAA0CK,CAAC,EAA3C,EAA+C;QAC3C,IAAMC,KAAK,GAAG,uBAAI,gCAAcL,YAAd,EAA4BC,SAA5B,EAAuCG,CAAvC,CAAJ,IAAiDD,eAA/D;QACAD,OAAO,CAACR,IAARQ,CAAa,wBAAa,4BAAiBJ,aAAa,CAACM,CAAD,CAA9B,CAAb,EAAiD,4BAAiBC,KAAjB,CAAjD,CAAbH;MACH;;MAED,OAAO,wBAAaA,OAAb,CAAP;IACH;EA9CK;AAZkB,CAAhC;eA8De7B","names":["lsolvePlugin","lsolveHeader","type","name","evaluate","repeat","documentation","en","synopsis","description","de","header","expression","evaluator","parameters","context","equations","map","parameter","forEach","normalizedParameter","push","_error","equation","options","variableNames","length","coefficients","constants","results","coefficientsDet","i","value"],"sources":["/home/behrenle/Projects/private/arithmico-calculator/node_modules/@behrenle/number-cruncher/src/plugins/core/lsolve/lsolve.ts"],"sourcesContent":["import createEquals from '../../../create/Equals';\nimport createFunctionCall from '../../../create/FunctionCall';\nimport createNumberNode from '../../../create/NumberNode';\nimport createSymbolNode from '../../../create/SymbolNode';\nimport createVector from '../../../create/Vector';\nimport normalize from '../../../normalize';\nimport serialize from '../../../serialize';\nimport { Equals, FunctionHeaderItem } from '../../../types/SyntaxTreeNodes';\nimport { addPluginAuthor, addPluginDescription, addPluginFunction, createPlugin } from '../../../utils/plugin-builder';\nimport { det } from './utils/calculate-det';\nimport { isEquationLinear } from './utils/check-linear';\nimport { getCoefficientMatrix, getConstantVector, getVariableNamesFromEquations } from './utils/get-coefficients';\nimport { replaceColumn } from './utils/matrix-utils';\n\nconst lsolvePlugin = createPlugin('lsolve');\n\naddPluginAuthor(lsolvePlugin, 'core');\naddPluginDescription(lsolvePlugin, 'adds lsolve function');\n\nconst lsolveHeader: FunctionHeaderItem[] = [{ type: 'equals', name: 'equation', evaluate: false, repeat: true }];\n\naddPluginFunction(lsolvePlugin, {\n    name: 'lsolve',\n    documentation: {\n        en: {\n            synopsis: 'lsolve(equation, ...)',\n            description: 'If possible, solve the set of linear equations.',\n        },\n        de: {\n            synopsis: 'lsolve(equation, ...)',\n            description: 'Löst, falls möglich, das lineare Gleichungssystem.',\n        },\n    },\n    function: {\n        type: 'function',\n        header: lsolveHeader,\n        expression: createFunctionCall(createSymbolNode('lsolve'), [createSymbolNode('equation+')]),\n        evaluator: (parameters, context) => {\n            const equations: Equals[] = [];\n            try {\n                parameters\n                    .map((parameter) => normalize(parameter, context))\n                    .forEach((normalizedParameter) => {\n                        if (normalizedParameter.type !== 'equals') {\n                            throw '';\n                        }\n                        equations.push(normalizedParameter);\n                    });\n            } catch (_error) {\n                throw 'lsolve: invalid equation(s)';\n            }\n\n            equations.forEach((equation) => {\n                if (!isEquationLinear(equation, context)) {\n                    throw `lsolve: \"${serialize(equation, context.options)}\" is not linear`;\n                }\n            });\n\n            const variableNames = getVariableNamesFromEquations(equations, context);\n\n            if (variableNames.length !== equations.length) {\n                throw 'RuntimeError: lsolve: invalid number of variables';\n            }\n\n            const coefficients = getCoefficientMatrix(equations, context);\n            const constants = getConstantVector(equations);\n            const results: Equals[] = [];\n            const coefficientsDet = det(coefficients);\n\n            if (coefficientsDet === 0) {\n                throw 'SolveError: The equation system has no solution';\n            }\n\n            for (let i = 0; i < variableNames.length; i++) {\n                const value = det(replaceColumn(coefficients, constants, i)) / coefficientsDet;\n                results.push(createEquals(createSymbolNode(variableNames[i]), createNumberNode(value)));\n            }\n\n            return createVector(results);\n        },\n    },\n});\n\nexport default lsolvePlugin;\n"]},"metadata":{},"sourceType":"script"}