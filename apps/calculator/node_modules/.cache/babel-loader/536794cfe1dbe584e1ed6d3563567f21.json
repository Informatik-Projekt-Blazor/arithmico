{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.integrateIntervall = integrateIntervall;\n\nvar _eval = _interopRequireDefault(require(\"../../../eval\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nvar positionWheightPairs = [[0.9914553711208126, 0.022935322010529224], [0.9491079123427585, 0.06309209262997856], [0.8648644233597691, 0.10479001032225019], [0.7415311855993945, 0.14065325971552592], [0.5860872354676911, 0.1690047266392679], [0.4058451513773972, 0.19035057806478542], [0.20778495500789848, 0.20443294007529889], [0, 0.20948214108472782], [-0.20778495500789848, 0.20443294007529889], [-0.4058451513773972, 0.19035057806478542], [-0.5860872354676911, 0.1690047266392679], [-0.7415311855993945, 0.14065325971552592], [-0.8648644233597691, 0.10479001032225019], [-0.9491079123427585, 0.06309209262997856], [-0.9914553711208126, 0.022935322010529224]];\n\nfunction mapPositionWheightPairsToIntervall(leftLimit, rightLimit) {\n  return positionWheightPairs.map(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        x = _ref2[0],\n        w = _ref2[1];\n\n    return [(rightLimit - leftLimit) / 2 * x + (leftLimit + rightLimit) / 2, w];\n  });\n}\n\nfunction integrateIntervall(leftLimit, rightLimit, expression, value, context) {\n  var errors = 0;\n  var positionWheightPairs = mapPositionWheightPairsToIntervall(leftLimit, rightLimit);\n  var values = positionWheightPairs.map(function (_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n        x = _ref4[0],\n        w = _ref4[1];\n\n    value.value = x;\n\n    try {\n      var result = (0, _eval[\"default\"])(expression, context);\n\n      if (result.type !== 'number') {\n        throw '';\n      }\n\n      return result.value * w;\n    } catch (_unused) {\n      errors++;\n      return 0;\n    }\n  }); // allows one undefined position per interval\n\n  if (errors > 1) {\n    throw 'RuntimeError: unable to integrate function';\n  }\n\n  return (rightLimit - leftLimit) / 2 * values.reduce(function (a, b) {\n    return a + b;\n  });\n}","map":{"version":3,"mappings":";;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA,IAAMA,oBAAoB,GAAG,CACzB,CAAC,kBAAD,EAAqB,oBAArB,CADyB,EAEzB,CAAC,kBAAD,EAAqB,mBAArB,CAFyB,EAGzB,CAAC,kBAAD,EAAqB,mBAArB,CAHyB,EAIzB,CAAC,kBAAD,EAAqB,mBAArB,CAJyB,EAKzB,CAAC,kBAAD,EAAqB,kBAArB,CALyB,EAMzB,CAAC,kBAAD,EAAqB,mBAArB,CANyB,EAOzB,CAAC,mBAAD,EAAsB,mBAAtB,CAPyB,EAQzB,CAAC,CAAD,EAAI,mBAAJ,CARyB,EASzB,CAAC,CAAC,mBAAF,EAAuB,mBAAvB,CATyB,EAUzB,CAAC,CAAC,kBAAF,EAAsB,mBAAtB,CAVyB,EAWzB,CAAC,CAAC,kBAAF,EAAsB,kBAAtB,CAXyB,EAYzB,CAAC,CAAC,kBAAF,EAAsB,mBAAtB,CAZyB,EAazB,CAAC,CAAC,kBAAF,EAAsB,mBAAtB,CAbyB,EAczB,CAAC,CAAC,kBAAF,EAAsB,mBAAtB,CAdyB,EAezB,CAAC,CAAC,kBAAF,EAAsB,oBAAtB,CAfyB,CAA7B;;AAkBA,SAASC,kCAAT,CAA4CC,SAA5C,EAA+DC,UAA/D,EAAmF;EAC/E,OAAOH,oBAAoB,CAACI,GAArBJ,CAAyB;IAAA;IAAA,IAAEK,CAAF;IAAA,IAAKC,CAAL;;IAAA,OAAY,CAAE,CAACH,UAAU,GAAGD,SAAd,IAA2B,CAA3B,GAAgCG,CAAhC,GAAoC,CAACH,SAAS,GAAGC,UAAb,IAA2B,CAAjE,EAAoEG,CAApE,CAAZ;EAAzB,EAAP;AACH;;AAEM,SAASC,kBAAT,CACHL,SADG,EAEHC,UAFG,EAGHK,UAHG,EAIHC,KAJG,EAKHC,OALG,EAMG;EACN,IAAIC,MAAM,GAAG,CAAb;EACA,IAAMX,oBAAoB,GAAGC,kCAAkC,CAACC,SAAD,EAAYC,UAAZ,CAA/D;EACA,IAAMS,MAAM,GAAGZ,oBAAoB,CAACI,GAArBJ,CAAyB,iBAAY;IAAA;IAAA,IAAVK,CAAU;IAAA,IAAPC,CAAO;;IAChDG,KAAK,CAACA,KAANA,GAAcJ,CAAdI;;IACA,IAAI;MACA,IAAMI,MAAM,GAAG,sBAASL,UAAT,EAAqBE,OAArB,CAAf;;MAEA,IAAIG,MAAM,CAACC,IAAPD,KAAgB,QAApB,EAA8B;QAC1B,MAAM,EAAN;MACH;;MAED,OAAOA,MAAM,CAACJ,KAAPI,GAAeP,CAAtB;IAPJ,EAQE,gBAAM;MACJK,MAAM;MACN,OAAO,CAAP;IACH;EAbU,EAAf,CAHM,CAmBN;;EACA,IAAIA,MAAM,GAAG,CAAb,EAAgB;IACZ,MAAM,4CAAN;EACH;;EAED,OAAQ,CAACR,UAAU,GAAGD,SAAd,IAA2B,CAA3B,GAAgCU,MAAM,CAACG,MAAPH,CAAc,UAACI,CAAD,EAAIC,CAAJ;IAAA,OAAUD,CAAC,GAAGC,CAAd;EAAd,EAAxC;AACH","names":["positionWheightPairs","mapPositionWheightPairsToIntervall","leftLimit","rightLimit","map","x","w","integrateIntervall","expression","value","context","errors","values","result","type","reduce","a","b"],"sources":["/home/behrenle/Projects/private/arithmico-calculator/node_modules/@behrenle/number-cruncher/src/plugins/core/nintegrate/utils.ts"],"sourcesContent":["import evaluate from '../../../eval';\nimport { Context, NumberNode, SyntaxTreeNode } from '../../../types';\n\nconst positionWheightPairs = [\n    [0.9914553711208126, 0.022935322010529224],\n    [0.9491079123427585, 0.06309209262997856],\n    [0.8648644233597691, 0.10479001032225019],\n    [0.7415311855993945, 0.14065325971552592],\n    [0.5860872354676911, 0.1690047266392679],\n    [0.4058451513773972, 0.19035057806478542],\n    [0.20778495500789848, 0.20443294007529889],\n    [0, 0.20948214108472782],\n    [-0.20778495500789848, 0.20443294007529889],\n    [-0.4058451513773972, 0.19035057806478542],\n    [-0.5860872354676911, 0.1690047266392679],\n    [-0.7415311855993945, 0.14065325971552592],\n    [-0.8648644233597691, 0.10479001032225019],\n    [-0.9491079123427585, 0.06309209262997856],\n    [-0.9914553711208126, 0.022935322010529224],\n];\n\nfunction mapPositionWheightPairsToIntervall(leftLimit: number, rightLimit: number) {\n    return positionWheightPairs.map(([x, w]) => [((rightLimit - leftLimit) / 2) * x + (leftLimit + rightLimit) / 2, w]);\n}\n\nexport function integrateIntervall(\n    leftLimit: number,\n    rightLimit: number,\n    expression: SyntaxTreeNode,\n    value: NumberNode,\n    context: Context,\n): number {\n    let errors = 0;\n    const positionWheightPairs = mapPositionWheightPairsToIntervall(leftLimit, rightLimit);\n    const values = positionWheightPairs.map(([x, w]) => {\n        value.value = x;\n        try {\n            const result = evaluate(expression, context);\n\n            if (result.type !== 'number') {\n                throw '';\n            }\n\n            return result.value * w;\n        } catch {\n            errors++;\n            return 0;\n        }\n    });\n\n    // allows one undefined position per interval\n    if (errors > 1) {\n        throw 'RuntimeError: unable to integrate function';\n    }\n\n    return ((rightLimit - leftLimit) / 2) * values.reduce((a, b) => a + b);\n}\n"]},"metadata":{},"sourceType":"script"}