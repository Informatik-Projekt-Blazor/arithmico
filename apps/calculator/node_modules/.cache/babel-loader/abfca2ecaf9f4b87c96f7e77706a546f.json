{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = evaluateLambda;\n\nvar _ = _interopRequireDefault(require(\"..\"));\n\nvar _Function = _interopRequireDefault(require(\"../../create/Function\"));\n\nvar _parameterUtils = require(\"../../utils/parameter-utils\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction evaluateLambda(node, context) {\n  if (!context.options.config.operators.lambda) {\n    throw \"RuntimeError: lambdas are disabled in this configuration\";\n  }\n\n  var evaluator = function evaluator(parameters, context) {\n    var localStackFrame = (0, _parameterUtils.mapParametersToStackFrame)('lambda', parameters, node.header, context);\n\n    var localContext = _objectSpread(_objectSpread({}, context), {}, {\n      stack: [].concat(_toConsumableArray(context.stack), [localStackFrame])\n    });\n\n    return (0, _[\"default\"])(node.expression, localContext);\n  };\n\n  return (0, _Function[\"default\"])(evaluator, node.header, node.expression);\n}","map":{"version":3,"mappings":";;;;;;;AAEA;;AAEA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEe,SAASA,cAAT,CAAwBC,IAAxB,EAAsCC,OAAtC,EAAwE;EACnF,IAAI,CAACA,OAAO,CAACC,OAARD,CAAgBE,MAAhBF,CAAuBG,SAAvBH,CAAiCI,MAAtC,EAA8C;IAC1C;EACH;;EAED,IAAMC,SAAS,GAAG,SAAZA,SAAY,CAACC,UAAD,EAA+BN,OAA/B,EAAoD;IAClE,IAAMO,eAA2B,GAAG,+CAA0B,QAA1B,EAAoCD,UAApC,EAAgDP,IAAI,CAACS,MAArD,EAA6DR,OAA7D,CAApC;;IAEA,IAAMS,YAAY,mCACXT,OADW;MAEdU,KAAK,+BAAMV,OAAO,CAACU,KAAd,IAAqBH,eAArB;IAFS,EAAlB;;IAKA,OAAO,kBAASR,IAAI,CAACY,UAAd,EAA0BF,YAA1B,CAAP;EARJ;;EAWA,OAAO,0BAAeJ,SAAf,EAA0BN,IAAI,CAACS,MAA/B,EAAuCT,IAAI,CAACY,UAA5C,CAAP;AACH","names":["evaluateLambda","node","context","options","config","operators","lambda","evaluator","parameters","localStackFrame","header","localContext","stack","expression"],"sources":["/home/behrenle/Projects/private/arithmico-calculator/node_modules/@behrenle/number-cruncher/src/eval/nodes/Lambda.ts"],"sourcesContent":["import { Context } from './../../types/Context';\nimport { StackFrame } from '../../types/Context';\nimport evaluate from '..';\nimport { SyntaxTreeNode, Lambda } from '../../types';\nimport createFunction from '../../create/Function';\nimport { mapParametersToStackFrame } from '../../utils/parameter-utils';\n\nexport default function evaluateLambda(node: Lambda, context: Context): SyntaxTreeNode {\n    if (!context.options.config.operators.lambda) {\n        throw `RuntimeError: lambdas are disabled in this configuration`;\n    }\n\n    const evaluator = (parameters: SyntaxTreeNode[], context: Context) => {\n        const localStackFrame: StackFrame = mapParametersToStackFrame('lambda', parameters, node.header, context);\n\n        const localContext = {\n            ...context,\n            stack: [...context.stack, localStackFrame],\n        };\n\n        return evaluate(node.expression, localContext);\n    };\n\n    return createFunction(evaluator, node.header, node.expression);\n}\n"]},"metadata":{},"sourceType":"script"}