{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = equals;\n\nvar _symbolicUtils = require(\"./../utils/symbolic-utils\");\n\nvar _parameterUtils = require(\"../utils/parameter-utils\");\n\nfunction compareAssociativeBinaryNodes(left, right) {\n  return equals(left.left, right.left) && equals(left.right, right.right) || equals(left.left, right.right) && equals(left.right, right.left);\n}\n\nfunction compareBinaryNodes(left, right) {\n  return equals(left.left, right.left) && equals(left.right, right.right);\n}\n\nfunction equals(left, right) {\n  if (left.type !== right.type) {\n    return false;\n  }\n\n  if (_symbolicUtils.associativeBinaryNodeTypes.includes(left.type)) {\n    return compareAssociativeBinaryNodes(left, right);\n  } else if (_symbolicUtils.binaryNodeTypes.includes(left.type)) {\n    return compareBinaryNodes(left, right);\n  }\n\n  switch (left.type) {\n    case 'number':\n      return left.value === right.value;\n\n    case 'boolean':\n      return left.value === right.value;\n\n    case 'symbol':\n      return left.name === right.name;\n\n    case 'negate':\n      return equals(left.value, right.value);\n\n    case 'function':\n      return (0, _parameterUtils.compareFunctionHeaders)(left.header, right.header) && equals(left.expression, right.expression);\n\n    case 'functionCall':\n      return equals(left[\"function\"], right[\"function\"]) && left.parameters.length === right.parameters.length && left.parameters.every(function (p, i) {\n        return equals(p, right.parameters[i]);\n      });\n\n    case 'define':\n      return left.name === right.name && equals(left.value, right.value);\n\n    case 'lambda':\n      return (0, _parameterUtils.compareFunctionHeaders)(left.header, right.header) && equals(left.expression, right.expression);\n\n    case 'vector':\n      return left.values.length === right.values.length && left.values.every(function (v, i) {\n        return equals(v, right.values[i]);\n      });\n  }\n\n  throw \"ComparisonError: unknown node tpye \".concat(left.type);\n}","map":{"version":3,"mappings":"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","names":["compareAssociativeBinaryNodes","left","right","equals","compareBinaryNodes","type","associativeBinaryNodeTypes","includes","binaryNodeTypes","value","name","header","expression","parameters","length","every","p","i","values","v"],"sources":["/home/behrenle/Projects/private/arithmico-calculator/node_modules/@behrenle/number-cruncher/src/equals/equals.ts"],"sourcesContent":["import { associativeBinaryNodeTypes, binaryNodeTypes } from './../utils/symbolic-utils';\nimport { compareFunctionHeaders } from '../utils/parameter-utils';\nimport {\n    NumberNode,\n    SyntaxTreeNode,\n    BinarySyntaxTreeNode,\n    BooleanNode,\n    SymbolNode,\n    Negate,\n    Define,\n    FunctionCall,\n    FunctionNode,\n    Lambda,\n    Vector,\n} from './../types/SyntaxTreeNodes';\n\nfunction compareAssociativeBinaryNodes(left: BinarySyntaxTreeNode, right: BinarySyntaxTreeNode): boolean {\n    return (\n        (equals(left.left, right.left) && equals(left.right, right.right)) ||\n        (equals(left.left, right.right) && equals(left.right, right.left))\n    );\n}\n\nfunction compareBinaryNodes(left: BinarySyntaxTreeNode, right: BinarySyntaxTreeNode): boolean {\n    return equals(left.left, right.left) && equals(left.right, right.right);\n}\n\nexport default function equals(left: SyntaxTreeNode, right: SyntaxTreeNode): boolean {\n    if (left.type !== right.type) {\n        return false;\n    }\n\n    if ((<string[]>associativeBinaryNodeTypes).includes(left.type)) {\n        return compareAssociativeBinaryNodes(<BinarySyntaxTreeNode>left, <BinarySyntaxTreeNode>right);\n    } else if ((<string[]>binaryNodeTypes).includes(left.type)) {\n        return compareBinaryNodes(<BinarySyntaxTreeNode>left, <BinarySyntaxTreeNode>right);\n    }\n\n    switch (left.type) {\n        case 'number':\n            return left.value === (<NumberNode>right).value;\n\n        case 'boolean':\n            return left.value === (<BooleanNode>right).value;\n\n        case 'symbol':\n            return left.name === (<SymbolNode>right).name;\n\n        case 'negate':\n            return equals(left.value, (<Negate>right).value);\n\n        case 'function':\n            return (\n                compareFunctionHeaders(left.header, (<FunctionNode>right).header) &&\n                equals(left.expression, (<FunctionNode>right).expression)\n            );\n\n        case 'functionCall':\n            return (\n                equals(left.function, (<FunctionCall>right).function) &&\n                left.parameters.length === (<FunctionCall>right).parameters.length &&\n                left.parameters.every((p, i) => equals(p, (<FunctionCall>right).parameters[i]))\n            );\n\n        case 'define':\n            return left.name === (<Define>right).name && equals(left.value, (<Define>right).value);\n\n        case 'lambda':\n            return (\n                compareFunctionHeaders(left.header, (<Lambda>right).header) &&\n                equals(left.expression, (<Lambda>right).expression)\n            );\n\n        case 'vector':\n            return (\n                left.values.length === (<Vector>right).values.length &&\n                left.values.every((v, i) => equals(v, (<Vector>right).values[i]))\n            );\n    }\n\n    throw `ComparisonError: unknown node tpye ${left.type}`;\n}\n"]},"metadata":{},"sourceType":"script"}