{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _NumberNode = _interopRequireDefault(require(\"../../../create/NumberNode\"));\n\nvar _parameterUtils = require(\"../../../utils/parameter-utils\");\n\nvar _pluginBuilder = require(\"../../../utils/plugin-builder\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar minmaxPlugin = (0, _pluginBuilder.createPlugin)('minmax');\n(0, _pluginBuilder.addPluginAuthor)(minmaxPlugin, 'core');\n(0, _pluginBuilder.addPluginDescription)(minmaxPlugin, 'adds min and max functions');\nvar header = [{\n  name: 'v',\n  type: 'number',\n  evaluate: true,\n  repeat: true\n}];\n(0, _pluginBuilder.addPluginFunction)(minmaxPlugin, (0, _pluginBuilder.createPluginFunction)('min', header, 'returns the minimum of all passed parameters', 'Gibt das Minimum aus allen übergebenen Werten zurück.', function (parameters, context) {\n  var parameterStackFrame = (0, _parameterUtils.mapParametersToStackFrame)('min', parameters, header, context);\n  var values = Object.values(parameterStackFrame).map(function (value) {\n    return value.value;\n  });\n  return (0, _NumberNode[\"default\"])(Math.min.apply(Math, _toConsumableArray(values)));\n}));\n(0, _pluginBuilder.addPluginFunction)(minmaxPlugin, (0, _pluginBuilder.createPluginFunction)('max', header, 'returns the maximum of all passed parameters', 'Gibt das Maximum aus allen übergebenen Werten zurück.', function (parameters, context) {\n  var parameterStackFrame = (0, _parameterUtils.mapParametersToStackFrame)('max', parameters, header, context);\n  var values = Object.values(parameterStackFrame).map(function (value) {\n    return value.value;\n  });\n  return (0, _NumberNode[\"default\"])(Math.max.apply(Math, _toConsumableArray(values)));\n}));\nvar _default = minmaxPlugin;\nexports[\"default\"] = _default;","map":{"version":3,"mappings":";;;;;;;AAAA;;AAEA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAQA,IAAMA,YAAY,GAAG,iCAAa,QAAb,CAArB;AACA,oCAAgBA,YAAhB,EAA8B,MAA9B;AACA,yCAAqBA,YAArB,EAAmC,4BAAnC;AAEA,IAAMC,MAA4B,GAAG,CAAC;EAAEC,IAAI,EAAE,GAAR;EAAaC,IAAI,EAAE,QAAnB;EAA6BC,QAAQ,EAAE,IAAvC;EAA6CC,MAAM,EAAE;AAArD,CAAD,CAArC;AAEA,sCACIL,YADJ,EAEI,yCACI,KADJ,EAEIC,MAFJ,EAGI,8CAHJ,EAII,uDAJJ,EAKI,UAACK,UAAD,EAAaC,OAAb,EAAyB;EACrB,IAAMC,mBAAmB,GAAG,+CAA0B,KAA1B,EAAiCF,UAAjC,EAA6CL,MAA7C,EAAqDM,OAArD,CAA5B;EACA,IAAME,MAAM,GAAGC,MAAM,CAACD,MAAPC,CAAcF,mBAAdE,EAAmCC,GAAnCD,CAAuC,UAACE,KAAD;IAAA,OAAwBA,KAAb,CAAoBA,KAA/B;EAAvC,EAAf;EACA,OAAO,4BAAiBC,IAAI,CAACC,GAALD,aAAIE,mBAAQN,MAAR,CAAJI,CAAjB,CAAP;AARR,EAFJ;AAeA,sCACIb,YADJ,EAEI,yCACI,KADJ,EAEIC,MAFJ,EAGI,8CAHJ,EAII,uDAJJ,EAMI,UAACK,UAAD,EAAaC,OAAb,EAAyB;EACrB,IAAMC,mBAAmB,GAAG,+CAA0B,KAA1B,EAAiCF,UAAjC,EAA6CL,MAA7C,EAAqDM,OAArD,CAA5B;EACA,IAAME,MAAM,GAAGC,MAAM,CAACD,MAAPC,CAAcF,mBAAdE,EAAmCC,GAAnCD,CAAuC,UAACE,KAAD;IAAA,OAAwBA,KAAb,CAAoBA,KAA/B;EAAvC,EAAf;EACA,OAAO,4BAAiBC,IAAI,CAACG,GAALH,aAAIE,mBAAQN,MAAR,CAAJI,CAAjB,CAAP;AATR,EAFJ;eAgBeb","names":["minmaxPlugin","header","name","type","evaluate","repeat","parameters","context","parameterStackFrame","values","Object","map","value","Math","min","_toConsumableArray","max"],"sources":["/home/behrenle/Projects/private/arithmico-calculator/node_modules/@behrenle/number-cruncher/src/plugins/core/minmax/minmax.ts"],"sourcesContent":["import createNumberNode from '../../../create/NumberNode';\nimport { FunctionHeaderItem, NumberNode } from '../../../types/SyntaxTreeNodes';\nimport { mapParametersToStackFrame } from '../../../utils/parameter-utils';\nimport {\n    addPluginAuthor,\n    addPluginDescription,\n    addPluginFunction,\n    createPlugin,\n    createPluginFunction,\n} from '../../../utils/plugin-builder';\n\nconst minmaxPlugin = createPlugin('minmax');\naddPluginAuthor(minmaxPlugin, 'core');\naddPluginDescription(minmaxPlugin, 'adds min and max functions');\n\nconst header: FunctionHeaderItem[] = [{ name: 'v', type: 'number', evaluate: true, repeat: true }];\n\naddPluginFunction(\n    minmaxPlugin,\n    createPluginFunction(\n        'min',\n        header,\n        'returns the minimum of all passed parameters',\n        'Gibt das Minimum aus allen übergebenen Werten zurück.',\n        (parameters, context) => {\n            const parameterStackFrame = mapParametersToStackFrame('min', parameters, header, context);\n            const values = Object.values(parameterStackFrame).map((value) => (<NumberNode>value).value);\n            return createNumberNode(Math.min(...values));\n        },\n    ),\n);\n\naddPluginFunction(\n    minmaxPlugin,\n    createPluginFunction(\n        'max',\n        header,\n        'returns the maximum of all passed parameters',\n        'Gibt das Maximum aus allen übergebenen Werten zurück.',\n\n        (parameters, context) => {\n            const parameterStackFrame = mapParametersToStackFrame('max', parameters, header, context);\n            const values = Object.values(parameterStackFrame).map((value) => (<NumberNode>value).value);\n            return createNumberNode(Math.max(...values));\n        },\n    ),\n);\n\nexport default minmaxPlugin;\n"]},"metadata":{},"sourceType":"script"}