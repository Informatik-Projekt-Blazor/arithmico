{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _Divided = _interopRequireDefault(require(\"../../../create/Divided\"));\n\nvar _NumberNode = _interopRequireDefault(require(\"../../../create/NumberNode\"));\n\nvar _parameterUtils = require(\"../../../utils/parameter-utils\");\n\nvar _pluginBuilder = require(\"../../../utils/plugin-builder\");\n\nvar _utils = require(\"./utils\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nvar fractionPlugin = (0, _pluginBuilder.createPlugin)('fraction');\n(0, _pluginBuilder.addPluginDescription)(fractionPlugin, 'adds fraction function');\n(0, _pluginBuilder.addPluginAuthor)(fractionPlugin, 'core');\nvar header = [{\n  name: 'x',\n  type: 'number',\n  evaluate: true\n}];\n(0, _pluginBuilder.addPluginFunction)(fractionPlugin, (0, _pluginBuilder.createPluginFunction)('fraction', header, 'Calculates the nearest fraction', 'Berechnet den nächsten Bruch zu x.', function (parameters, context) {\n  var parameterStackFrame = (0, _parameterUtils.mapParametersToStackFrame)('fraction', parameters, header, context);\n  var value = parameterStackFrame['x'].value;\n\n  if (value === 0) {\n    return (0, _NumberNode[\"default\"])(0);\n  }\n\n  var _getLowestFraction = (0, _utils.getLowestFraction)(value),\n      _getLowestFraction2 = _slicedToArray(_getLowestFraction, 2),\n      left = _getLowestFraction2[0],\n      right = _getLowestFraction2[1];\n\n  return (0, _Divided[\"default\"])((0, _NumberNode[\"default\"])(left), (0, _NumberNode[\"default\"])(right));\n}));\nvar _default = fractionPlugin;\nexports[\"default\"] = _default;","map":{"version":3,"mappings":";;;;;;;AAAA;;AACA;;AAEA;;AACA;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,IAAMA,cAAc,GAAG,iCAAa,UAAb,CAAvB;AACA,yCAAqBA,cAArB,EAAqC,wBAArC;AACA,oCAAgBA,cAAhB,EAAgC,MAAhC;AAEA,IAAMC,MAA4B,GAAG,CAAC;EAAEC,IAAI,EAAE,GAAR;EAAaC,IAAI,EAAE,QAAnB;EAA6BC,QAAQ,EAAE;AAAvC,CAAD,CAArC;AAEA,sCACIJ,cADJ,EAEI,yCACI,UADJ,EAEIC,MAFJ,EAGI,iCAHJ,EAII,oCAJJ,EAKI,UAACI,UAAD,EAAaC,OAAb,EAAyB;EACrB,IAAMC,mBAAmB,GAAG,+CAA0B,UAA1B,EAAsCF,UAAtC,EAAkDJ,MAAlD,EAA0DK,OAA1D,CAA5B;EACA,IAAME,KAAK,GAAgBD,mBAAmB,CAAC,GAAD,CAAnBA,CAA0BC,KAArD;;EAEA,IAAIA,KAAK,KAAK,CAAd,EAAiB;IACb,OAAO,4BAAiB,CAAjB,CAAP;EACH;;EANoB,yBAQC,8BAAkBA,KAAlB,CARD;EAAA;EAAA,IAQdC,IARc;EAAA,IAQRC,KARQ;;EASrB,OAAO,yBAAc,4BAAiBD,IAAjB,CAAd,EAAsC,4BAAiBC,KAAjB,CAAtC,CAAP;AAdR,EAFJ;eAqBeV","names":["fractionPlugin","header","name","type","evaluate","parameters","context","parameterStackFrame","value","left","right"],"sources":["/home/behrenle/Projects/private/arithmico-calculator/node_modules/@behrenle/number-cruncher/src/plugins/core/fraction/fraction.ts"],"sourcesContent":["import createDivided from '../../../create/Divided';\nimport createNumberNode from '../../../create/NumberNode';\nimport { FunctionHeaderItem, NumberNode } from '../../../types/SyntaxTreeNodes';\nimport { mapParametersToStackFrame } from '../../../utils/parameter-utils';\nimport {\n    addPluginAuthor,\n    addPluginDescription,\n    addPluginFunction,\n    createPlugin,\n    createPluginFunction,\n} from '../../../utils/plugin-builder';\nimport { getLowestFraction } from './utils';\n\nconst fractionPlugin = createPlugin('fraction');\naddPluginDescription(fractionPlugin, 'adds fraction function');\naddPluginAuthor(fractionPlugin, 'core');\n\nconst header: FunctionHeaderItem[] = [{ name: 'x', type: 'number', evaluate: true }];\n\naddPluginFunction(\n    fractionPlugin,\n    createPluginFunction(\n        'fraction',\n        header,\n        'Calculates the nearest fraction',\n        'Berechnet den nächsten Bruch zu x.',\n        (parameters, context) => {\n            const parameterStackFrame = mapParametersToStackFrame('fraction', parameters, header, context);\n            const value = (<NumberNode>parameterStackFrame['x']).value;\n\n            if (value === 0) {\n                return createNumberNode(0);\n            }\n\n            const [left, right] = getLowestFraction(value);\n            return createDivided(createNumberNode(left), createNumberNode(right));\n        },\n    ),\n);\n\nexport default fractionPlugin;\n"]},"metadata":{},"sourceType":"script"}