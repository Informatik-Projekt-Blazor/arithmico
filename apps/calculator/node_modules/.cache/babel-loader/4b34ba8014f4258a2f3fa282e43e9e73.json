{"ast":null,"code":"import hotkeys from 'hotkeys-js';\nimport { useRef, useCallback, useEffect } from 'react';\n/**\r\n * @deprecated Use isHotkeyPressed instead. Will be removed version 4.\r\n */\n\nfunction useIsHotkeyPressed() {\n  return hotkeys.isPressed;\n}\n\nhotkeys.filter = function () {\n  return true;\n};\n\nvar tagFilter = function tagFilter(_ref, enableOnTags) {\n  var target = _ref.target;\n  var targetTagName = target && target.tagName;\n  return Boolean(targetTagName && enableOnTags && enableOnTags.includes(targetTagName));\n};\n\nvar isKeyboardEventTriggeredByInput = function isKeyboardEventTriggeredByInput(ev) {\n  return tagFilter(ev, ['INPUT', 'TEXTAREA', 'SELECT']);\n};\n\nfunction useHotkeys(keys, callback, options, deps) {\n  if (options instanceof Array) {\n    deps = options;\n    options = undefined;\n  }\n\n  var _ref2 = options || {},\n      enableOnTags = _ref2.enableOnTags,\n      filter = _ref2.filter,\n      keyup = _ref2.keyup,\n      keydown = _ref2.keydown,\n      _ref2$filterPreventDe = _ref2.filterPreventDefault,\n      filterPreventDefault = _ref2$filterPreventDe === void 0 ? true : _ref2$filterPreventDe,\n      _ref2$enabled = _ref2.enabled,\n      enabled = _ref2$enabled === void 0 ? true : _ref2$enabled,\n      _ref2$enableOnContent = _ref2.enableOnContentEditable,\n      enableOnContentEditable = _ref2$enableOnContent === void 0 ? false : _ref2$enableOnContent;\n\n  var ref = useRef(null); // The return value of this callback determines if the browsers default behavior is prevented.\n\n  var memoisedCallback = useCallback(function (keyboardEvent, hotkeysEvent) {\n    var _keyboardEvent$target;\n\n    if (filter && !filter(keyboardEvent)) {\n      return !filterPreventDefault;\n    } // Check whether the hotkeys was triggered inside an input and that input is enabled or if it was triggered by a content editable tag and it is enabled.\n\n\n    if (isKeyboardEventTriggeredByInput(keyboardEvent) && !tagFilter(keyboardEvent, enableOnTags) || (_keyboardEvent$target = keyboardEvent.target) != null && _keyboardEvent$target.isContentEditable && !enableOnContentEditable) {\n      return true;\n    }\n\n    if (ref.current === null || document.activeElement === ref.current) {\n      callback(keyboardEvent, hotkeysEvent);\n      return true;\n    }\n\n    return false;\n  }, deps ? [ref, enableOnTags, filter].concat(deps) : [ref, enableOnTags, filter]);\n  useEffect(function () {\n    if (!enabled) {\n      hotkeys.unbind(keys, memoisedCallback);\n      return;\n    } // In this case keydown is likely undefined, so we set it to false, since hotkeys needs the `keydown` key to have a value.\n\n\n    if (keyup && keydown !== true) {\n      options.keydown = false;\n    }\n\n    hotkeys(keys, options || {}, memoisedCallback);\n    return function () {\n      return hotkeys.unbind(keys, memoisedCallback);\n    };\n  }, [memoisedCallback, keys, enabled]);\n  return ref;\n}\n\nvar isHotkeyPressed = hotkeys.isPressed;\nexport { isHotkeyPressed, useHotkeys, useIsHotkeyPressed };","map":{"version":3,"mappings":"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","names":["useIsHotkeyPressed","hotkeys","isPressed","filter","tagFilter","enableOnTags","target","targetTagName","tagName","Boolean","includes","isKeyboardEventTriggeredByInput","ev","useHotkeys","keys","callback","options","deps","Array","undefined","keyup","keydown","filterPreventDefault","enabled","enableOnContentEditable","ref","useRef","memoisedCallback","useCallback","keyboardEvent","hotkeysEvent","isContentEditable","current","document","activeElement","useEffect","unbind","isHotkeyPressed"],"sources":["/home/behrenle/Projects/private/arithmico-calculator/node_modules/react-hotkeys-hook/src/useIsHotkeyPressed.ts","/home/behrenle/Projects/private/arithmico-calculator/node_modules/react-hotkeys-hook/src/useHotkeys.ts","/home/behrenle/Projects/private/arithmico-calculator/node_modules/react-hotkeys-hook/src/index.ts"],"sourcesContent":["import hotkeys from 'hotkeys-js';\n\n/**\n * @deprecated Use isHotkeyPressed instead. Will be removed version 4.\n */\nexport function useIsHotkeyPressed() {\n  return hotkeys.isPressed;\n}","import hotkeys, { HotkeysEvent, KeyHandler } from 'hotkeys-js';\nimport React, { useCallback, useEffect, useRef } from 'react';\n\ntype AvailableTags = 'INPUT' | 'TEXTAREA' | 'SELECT';\n\n// We implement our own custom filter system.\nhotkeys.filter = () => true;\n\nconst tagFilter = ({ target }: KeyboardEvent, enableOnTags?: AvailableTags[]) => {\n  const targetTagName = target && (target as HTMLElement).tagName;\n\n  return Boolean((targetTagName && enableOnTags && enableOnTags.includes(targetTagName as AvailableTags)));\n};\n\nconst isKeyboardEventTriggeredByInput = (ev: KeyboardEvent) => {\n  return tagFilter(ev, ['INPUT', 'TEXTAREA', 'SELECT']);\n};\n\nexport type Options = {\n  enabled?: boolean; // Main setting that determines if the hotkey is enabled or not. (Default: true)\n  filter?: typeof hotkeys.filter; // A filter function returning whether the callback should get triggered or not. (Default: undefined)\n  filterPreventDefault?: boolean; // Prevent default browser behavior if the filter function returns false. (Default: true)\n  enableOnTags?: AvailableTags[]; // Enable hotkeys on a list of tags. (Default: [])\n  enableOnContentEditable?: boolean; // Enable hotkeys on tags with contentEditable props. (Default: false)\n  splitKey?: string; // Character to split keys in hotkeys combinations. (Default +)\n  scope?: string; // Scope. Currently not doing anything.\n  keyup?: boolean; // Trigger on keyup event? (Default: undefined)\n  keydown?: boolean; // Trigger on keydown event? (Default: true)\n};\n\nexport function useHotkeys<T extends Element>(keys: string, callback: KeyHandler, options?: Options): React.MutableRefObject<T | null>;\nexport function useHotkeys<T extends Element>(keys: string, callback: KeyHandler, deps?: any[]): React.MutableRefObject<T | null>;\nexport function useHotkeys<T extends Element>(keys: string, callback: KeyHandler, options?: Options, deps?: any[]): React.MutableRefObject<T | null>;\nexport function useHotkeys<T extends Element>(keys: string, callback: KeyHandler, options?: any[] | Options, deps?: any[]): React.MutableRefObject<T | null> {\n  if (options instanceof Array) {\n    deps = options;\n    options = undefined;\n  }\n\n  const {\n    enableOnTags,\n    filter,\n    keyup,\n    keydown,\n    filterPreventDefault = true,\n    enabled = true,\n    enableOnContentEditable = false,\n  } = options as Options || {};\n  const ref = useRef<T | null>(null);\n\n  // The return value of this callback determines if the browsers default behavior is prevented.\n  const memoisedCallback = useCallback((keyboardEvent: KeyboardEvent, hotkeysEvent: HotkeysEvent) => {\n    if (filter && !filter(keyboardEvent)) {\n      return !filterPreventDefault;\n    }\n\n    // Check whether the hotkeys was triggered inside an input and that input is enabled or if it was triggered by a content editable tag and it is enabled.\n    if (\n      (isKeyboardEventTriggeredByInput(keyboardEvent) && !tagFilter(keyboardEvent, enableOnTags))\n      || ((keyboardEvent.target as HTMLElement)?.isContentEditable && !enableOnContentEditable)\n    ) {\n      return true;\n    }\n\n    if (ref.current === null || document.activeElement === ref.current) {\n      callback(keyboardEvent, hotkeysEvent);\n      return true;\n    }\n\n    return false;\n  }, deps ? [ref, enableOnTags, filter, ...deps] : [ref, enableOnTags, filter]);\n\n  useEffect(() => {\n    if (!enabled) {\n      hotkeys.unbind(keys, memoisedCallback);\n\n      return;\n    }\n\n    // In this case keydown is likely undefined, so we set it to false, since hotkeys needs the `keydown` key to have a value.\n    if (keyup && keydown !== true) {\n      (options as Options).keydown = false;\n    }\n\n    hotkeys(keys, (options as Options) || {}, memoisedCallback);\n\n    return () => hotkeys.unbind(keys, memoisedCallback);\n  }, [memoisedCallback, keys, enabled]);\n\n  return ref;\n}\n","import { useIsHotkeyPressed } from './useIsHotkeyPressed';\nimport { useHotkeys, Options } from './useHotkeys';\nimport hotkeys from 'hotkeys-js';\n\nconst isHotkeyPressed = hotkeys.isPressed;\n\nexport { useHotkeys, useIsHotkeyPressed, isHotkeyPressed, Options };"]},"metadata":{},"sourceType":"module"}