{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createPlugin = createPlugin;\nexports.createPluginFunction = createPluginFunction;\nexports.addPluginAuthor = addPluginAuthor;\nexports.addPluginDescription = addPluginDescription;\nexports.addPluginConstant = addPluginConstant;\nexports.addPluginFunction = addPluginFunction;\nexports.addPluginInlineDefinition = addPluginInlineDefinition;\n\nvar _FunctionCall = _interopRequireDefault(require(\"../create/FunctionCall\"));\n\nvar _SymbolNode = _interopRequireDefault(require(\"../create/SymbolNode\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction createPlugin(name) {\n  return {\n    name: name,\n    author: '',\n    description: '',\n    constants: [],\n    functions: [],\n    inlineDefinitions: []\n  };\n}\n\nfunction convertHeaderToSymbolList(header) {\n  var result = [];\n  header.forEach(function (item) {\n    if (item.optional) {\n      result.push((0, _SymbolNode[\"default\"])(item.name + '?'));\n    } else {\n      result.push((0, _SymbolNode[\"default\"])(item.name));\n    }\n\n    if (item.repeat) {\n      result.push((0, _SymbolNode[\"default\"])('...'));\n    }\n  });\n  return result;\n}\n\nfunction createPluginFunction(name, header, descriptionEn, descriptionDe, evaluator) {\n  var headerSymbols = convertHeaderToSymbolList(header);\n  var synopsis = \"\".concat(name, \"(\").concat(headerSymbols.map(function (symbol) {\n    return symbol.name;\n  }).join(', '), \")\");\n  var expression = (0, _FunctionCall[\"default\"])((0, _SymbolNode[\"default\"])(name), headerSymbols);\n  return {\n    name: name,\n    documentation: {\n      en: {\n        synopsis: synopsis,\n        description: descriptionEn\n      },\n      de: {\n        synopsis: synopsis,\n        description: descriptionDe\n      }\n    },\n    \"function\": {\n      type: 'function',\n      header: header,\n      expression: expression,\n      evaluator: evaluator\n    }\n  };\n}\n\nfunction addPluginAuthor(plugin, author) {\n  plugin.author = author;\n}\n\nfunction addPluginDescription(plugin, description) {\n  plugin.description = description;\n}\n\nfunction addPluginConstant(plugin, constant) {\n  plugin.constants = [].concat(_toConsumableArray(plugin.constants), [constant]);\n}\n\nfunction addPluginFunction(plugin, func) {\n  plugin.functions = [].concat(_toConsumableArray(plugin.functions), [func]);\n}\n\nfunction addPluginInlineDefinition(plugin, inlineDefinition) {\n  plugin.inlineDefinitions = [].concat(_toConsumableArray(plugin.inlineDefinitions), [inlineDefinition]);\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;AAGA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEO,SAASA,YAAT,CAAsBC,IAAtB,EAA4C;EAC/C,OAAO;IACHA,IAAI,EAAJA,IADG;IAEHC,MAAM,EAAE,EAFL;IAGHC,WAAW,EAAE,EAHV;IAIHC,SAAS,EAAE,EAJR;IAKHC,SAAS,EAAE,EALR;IAMHC,iBAAiB,EAAE;EANhB,CAAP;AAQH;;AAED,SAASC,yBAAT,CAAmCC,MAAnC,EAA+E;EAC3E,IAAMC,MAAoB,GAAG,EAA7B;EAEAD,MAAM,CAACE,OAAPF,CAAe,UAACG,IAAD,EAAU;IACrB,IAAIA,IAAI,CAACC,QAAT,EAAmB;MACfH,MAAM,CAACI,IAAPJ,CAAY,4BAAiBE,IAAI,CAACV,IAALU,GAAY,GAA7B,CAAZF;IADJ,OAEO;MACHA,MAAM,CAACI,IAAPJ,CAAY,4BAAiBE,IAAI,CAACV,IAAtB,CAAZQ;IACH;;IAED,IAAIE,IAAI,CAACG,MAAT,EAAiB;MACbL,MAAM,CAACI,IAAPJ,CAAY,4BAAiB,KAAjB,CAAZA;IACH;EATL;EAYA,OAAOA,MAAP;AACH;;AAEM,SAASM,oBAAT,CACHd,IADG,EAEHO,MAFG,EAGHQ,aAHG,EAIHC,aAJG,EAKHC,SALG,EAMW;EACd,IAAMC,aAAa,GAAGZ,yBAAyB,CAACC,MAAD,CAA/C;EACA,IAAMY,QAAQ,aAAMnB,IAAN,cAAckB,aAAa,CAACE,GAAdF,CAAkB,UAACG,MAAD;IAAA,OAAYA,MAAM,CAACrB,IAAnB;EAAlB,GAA2CsB,IAA3CJ,CAAgD,IAAhDA,CAAd,MAAd;EACA,IAAMK,UAAU,GAAG,8BAAmB,4BAAiBvB,IAAjB,CAAnB,EAA2CkB,aAA3C,CAAnB;EAEA,OAAO;IACHlB,IAAI,EAAJA,IADG;IAEHwB,aAAa,EAAE;MACXC,EAAE,EAAE;QACAN,QAAQ,EAARA,QADA;QAEAjB,WAAW,EAAEa;MAFb,CADO;MAKXW,EAAE,EAAE;QACAP,QAAQ,EAARA,QADA;QAEAjB,WAAW,EAAEc;MAFb;IALO,CAFZ;IAYH,YAAU;MACNW,IAAI,EAAE,UADA;MAENpB,MAAM,EAANA,MAFM;MAGNgB,UAAU,EAAVA,UAHM;MAINN,SAAS,EAATA;IAJM;EAZP,CAAP;AAmBH;;AAEM,SAASW,eAAT,CAAyBC,MAAzB,EAAyC5B,MAAzC,EAAyD;EAC5D4B,MAAM,CAAC5B,MAAP4B,GAAgB5B,MAAhB4B;AACH;;AAEM,SAASC,oBAAT,CAA8BD,MAA9B,EAA8C3B,WAA9C,EAAmE;EACtE2B,MAAM,CAAC3B,WAAP2B,GAAqB3B,WAArB2B;AACH;;AAEM,SAASE,iBAAT,CAA2BF,MAA3B,EAA2CG,QAA3C,EAAqE;EACxEH,MAAM,CAAC1B,SAAP0B,gCAAuBA,MAAM,CAAC1B,SAA9B,IAAyC6B,QAAzC;AACH;;AAEM,SAASC,iBAAT,CAA2BJ,MAA3B,EAA2CK,IAA3C,EAAiE;EACpEL,MAAM,CAACzB,SAAPyB,gCAAuBA,MAAM,CAACzB,SAA9B,IAAyC8B,IAAzC;AACH;;AAEM,SAASC,yBAAT,CAAmCN,MAAnC,EAAmDO,gBAAnD,EAA6E;EAChFP,MAAM,CAACxB,iBAAPwB,gCAA+BA,MAAM,CAACxB,iBAAtC,IAAyD+B,gBAAzD;AACH","names":["createPlugin","name","author","description","constants","functions","inlineDefinitions","convertHeaderToSymbolList","header","result","forEach","item","optional","push","repeat","createPluginFunction","descriptionEn","descriptionDe","evaluator","headerSymbols","synopsis","map","symbol","join","expression","documentation","en","de","type","addPluginAuthor","plugin","addPluginDescription","addPluginConstant","constant","addPluginFunction","func","addPluginInlineDefinition","inlineDefinition"],"sources":["/home/behrenle/Projects/private/arithmico-calculator/node_modules/@behrenle/number-cruncher/src/utils/plugin-builder.ts"],"sourcesContent":["import { PluginConstant, PluginFunction } from './../types/Plugin';\nimport { Plugin } from '../types/Plugin';\nimport { FunctionHeaderItem, FunctionNode, SymbolNode } from '../types/SyntaxTreeNodes';\nimport createFunctionCall from '../create/FunctionCall';\nimport createSymbolNode from '../create/SymbolNode';\n\nexport function createPlugin(name: string): Plugin {\n    return {\n        name,\n        author: '',\n        description: '',\n        constants: [],\n        functions: [],\n        inlineDefinitions: [],\n    };\n}\n\nfunction convertHeaderToSymbolList(header: FunctionHeaderItem[]): SymbolNode[] {\n    const result: SymbolNode[] = [];\n\n    header.forEach((item) => {\n        if (item.optional) {\n            result.push(createSymbolNode(item.name + '?'));\n        } else {\n            result.push(createSymbolNode(item.name));\n        }\n\n        if (item.repeat) {\n            result.push(createSymbolNode('...'));\n        }\n    });\n\n    return result;\n}\n\nexport function createPluginFunction(\n    name: string,\n    header: FunctionHeaderItem[],\n    descriptionEn: string,\n    descriptionDe: string,\n    evaluator: FunctionNode['evaluator'],\n): PluginFunction {\n    const headerSymbols = convertHeaderToSymbolList(header);\n    const synopsis = `${name}(${headerSymbols.map((symbol) => symbol.name).join(', ')})`;\n    const expression = createFunctionCall(createSymbolNode(name), headerSymbols);\n\n    return {\n        name,\n        documentation: {\n            en: {\n                synopsis,\n                description: descriptionEn,\n            },\n            de: {\n                synopsis,\n                description: descriptionDe,\n            },\n        },\n        function: {\n            type: 'function',\n            header,\n            expression,\n            evaluator,\n        },\n    };\n}\n\nexport function addPluginAuthor(plugin: Plugin, author: string) {\n    plugin.author = author;\n}\n\nexport function addPluginDescription(plugin: Plugin, description: string) {\n    plugin.description = description;\n}\n\nexport function addPluginConstant(plugin: Plugin, constant: PluginConstant) {\n    plugin.constants = [...plugin.constants, constant];\n}\n\nexport function addPluginFunction(plugin: Plugin, func: PluginFunction) {\n    plugin.functions = [...plugin.functions, func];\n}\n\nexport function addPluginInlineDefinition(plugin: Plugin, inlineDefinition: string) {\n    plugin.inlineDefinitions = [...plugin.inlineDefinitions, inlineDefinition];\n}\n"]},"metadata":{},"sourceType":"script"}