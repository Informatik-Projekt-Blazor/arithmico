{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getVariableNamesFromEquations = getVariableNamesFromEquations;\nexports.getCoefficientMatrix = getCoefficientMatrix;\nexports.getConstantVector = getConstantVector;\n\nvar _NumberNode = _interopRequireDefault(require(\"../../../../create/NumberNode\"));\n\nvar _symbolicUtils = require(\"../../../../utils/symbolic-utils\");\n\nvar _getFactors = require(\"./get-factors\");\n\nvar _getSummands = require(\"./get-summands\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction getSummandCoefficient(summand) {\n  var factors = (0, _getFactors.getFactors)(summand);\n  var coefficients = factors.filter(function (factor) {\n    return factor.type === 'number';\n  });\n\n  if (coefficients.length === 0) {\n    return (0, _NumberNode[\"default\"])(1);\n  }\n\n  if (coefficients.length === 1) {\n    return coefficients[0];\n  }\n\n  throw 'RuntimeError: multiple coefficients';\n}\n\nfunction getVariableNamesFromEquations(equations, context) {\n  return _toConsumableArray(equations.reduce(function (variableNames, equation) {\n    return new Set([].concat(_toConsumableArray(variableNames), _toConsumableArray((0, _symbolicUtils.getVariableNames)(equation, context))));\n  }, new Set()));\n}\n\nfunction getCoefficientMatrix(equations, context) {\n  var variableNames = getVariableNamesFromEquations(equations, context);\n  return equations.map(function (equation) {\n    var coefficients = new Array(variableNames.length).fill(0);\n    var summands = (0, _getSummands.getSummands)(equation);\n    summands.forEach(function (summand) {\n      var variables = (0, _symbolicUtils.getVariableNames)(summand, context);\n      var coefficient = getSummandCoefficient(summand);\n\n      if (variables.length !== 1) {\n        return;\n      }\n\n      var position = variableNames.indexOf(variables[0]);\n\n      if (position === -1) {\n        return;\n      }\n\n      coefficients[position] = coefficient.value;\n    });\n    return coefficients;\n  });\n}\n\nfunction getConstantVector(equations) {\n  return equations.map(function (equation) {\n    var summands = (0, _getSummands.getSummands)(equation);\n    var constants = summands.filter(function (summand) {\n      return summand.type === 'number';\n    });\n\n    if (constants.length === 0) {\n      return 0;\n    }\n\n    if (constants.length === 1) {\n      return -constants[0].value;\n    }\n\n    throw 'RuntimeError: cannot resolve multiple constants';\n  });\n}","map":{"version":3,"mappings":";;;;;;;;;AAAA;;AAEA;;AACA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,SAASA,qBAAT,CAA+BC,OAA/B,EAAoE;EAChE,IAAMC,OAAO,GAAG,4BAAWD,OAAX,CAAhB;EACA,IAAME,YAAY,GAAiBD,OAAO,CAACE,MAARF,CAAe,UAACG,MAAD;IAAA,OAAYA,MAAM,CAACC,IAAPD,KAAgB,QAA5B;EAAf,EAAnC;;EAEA,IAAIF,YAAY,CAACI,MAAbJ,KAAwB,CAA5B,EAA+B;IAC3B,OAAO,4BAAiB,CAAjB,CAAP;EACH;;EAED,IAAIA,YAAY,CAACI,MAAbJ,KAAwB,CAA5B,EAA+B;IAC3B,OAAOA,YAAY,CAAC,CAAD,CAAnB;EACH;;EAED,MAAM,qCAAN;AACH;;AAEM,SAASK,6BAAT,CAAuCC,SAAvC,EAA4DC,OAA5D,EAAwF;EAC3F,0BACOD,SAAS,CAACE,MAAVF,CACC,UAACG,aAAD,EAAgBC,QAAhB;IAAA,OAA6B,IAAIC,GAAJ,8BAAYF,aAAZ,sBAA8B,qCAAiBC,QAAjB,EAA2BH,OAA3B,CAA9B,GAA7B;EADD,GAEC,IAAII,GAAJ,EAFDL,CADP;AAMH;;AAEM,SAASM,oBAAT,CAA8BN,SAA9B,EAAmDC,OAAnD,EAAiF;EACpF,IAAME,aAAa,GAAGJ,6BAA6B,CAACC,SAAD,EAAYC,OAAZ,CAAnD;EAEA,OAAOD,SAAS,CAACO,GAAVP,CAAc,UAACI,QAAD,EAAc;IAC/B,IAAMV,YAAsB,GAAG,IAAIc,KAAJ,CAAUL,aAAa,CAACL,MAAxB,EAAgCW,IAAhC,CAAqC,CAArC,CAA/B;IACA,IAAMC,QAAQ,GAAG,8BAAYN,QAAZ,CAAjB;IAEAM,QAAQ,CAACC,OAATD,CAAiB,UAAClB,OAAD,EAAa;MAC1B,IAAMoB,SAAS,GAAG,qCAAiBpB,OAAjB,EAA0BS,OAA1B,CAAlB;MACA,IAAMY,WAAW,GAAGtB,qBAAqB,CAACC,OAAD,CAAzC;;MAEA,IAAIoB,SAAS,CAACd,MAAVc,KAAqB,CAAzB,EAA4B;QACxB;MACH;;MAED,IAAME,QAAQ,GAAGX,aAAa,CAACY,OAAdZ,CAAsBS,SAAS,CAAC,CAAD,CAA/BT,CAAjB;;MAEA,IAAIW,QAAQ,KAAK,CAAC,CAAlB,EAAqB;QACjB;MACH;;MAEDpB,YAAY,CAACoB,QAAD,CAAZpB,GAAyBmB,WAAW,CAACG,KAArCtB;IAdJ;IAiBA,OAAOA,YAAP;EArBG,EAAP;AAuBH;;AAEM,SAASuB,iBAAT,CAA2BjB,SAA3B,EAA0D;EAC7D,OAAOA,SAAS,CAACO,GAAVP,CAAc,UAACI,QAAD,EAAc;IAC/B,IAAMM,QAAQ,GAAG,8BAAYN,QAAZ,CAAjB;IACA,IAAMc,SAAS,GAAiBR,QAAQ,CAACf,MAATe,CAAgB,UAAClB,OAAD;MAAA,OAAaA,OAAO,CAACK,IAARL,KAAiB,QAA9B;IAAhB,EAAhC;;IAEA,IAAI0B,SAAS,CAACpB,MAAVoB,KAAqB,CAAzB,EAA4B;MACxB,OAAO,CAAP;IACH;;IAED,IAAIA,SAAS,CAACpB,MAAVoB,KAAqB,CAAzB,EAA4B;MACxB,OAAO,CAACA,SAAS,CAAC,CAAD,CAATA,CAAaF,KAArB;IACH;;IAED,MAAM,iDAAN;EAZG,EAAP;AAcH","names":["getSummandCoefficient","summand","factors","coefficients","filter","factor","type","length","getVariableNamesFromEquations","equations","context","reduce","variableNames","equation","Set","getCoefficientMatrix","map","Array","fill","summands","forEach","variables","coefficient","position","indexOf","value","getConstantVector","constants"],"sources":["/home/behrenle/Projects/private/arithmico-calculator/node_modules/@behrenle/number-cruncher/src/plugins/core/lsolve/utils/get-coefficients.ts"],"sourcesContent":["import createNumberNode from '../../../../create/NumberNode';\nimport { Context, Equals, NumberNode, SyntaxTreeNode } from '../../../../types';\nimport { getVariableNames } from '../../../../utils/symbolic-utils';\nimport { getFactors } from './get-factors';\nimport { getSummands } from './get-summands';\n\nfunction getSummandCoefficient(summand: SyntaxTreeNode): NumberNode {\n    const factors = getFactors(summand);\n    const coefficients = <NumberNode[]>factors.filter((factor) => factor.type === 'number');\n\n    if (coefficients.length === 0) {\n        return createNumberNode(1);\n    }\n\n    if (coefficients.length === 1) {\n        return coefficients[0];\n    }\n\n    throw 'RuntimeError: multiple coefficients';\n}\n\nexport function getVariableNamesFromEquations(equations: Equals[], context: Context): string[] {\n    return [\n        ...equations.reduce(\n            (variableNames, equation) => new Set([...variableNames, ...getVariableNames(equation, context)]),\n            new Set<string>(),\n        ),\n    ];\n}\n\nexport function getCoefficientMatrix(equations: Equals[], context: Context): number[][] {\n    const variableNames = getVariableNamesFromEquations(equations, context);\n\n    return equations.map((equation) => {\n        const coefficients: number[] = new Array(variableNames.length).fill(0);\n        const summands = getSummands(equation);\n\n        summands.forEach((summand) => {\n            const variables = getVariableNames(summand, context);\n            const coefficient = getSummandCoefficient(summand);\n\n            if (variables.length !== 1) {\n                return;\n            }\n\n            const position = variableNames.indexOf(variables[0]);\n\n            if (position === -1) {\n                return;\n            }\n\n            coefficients[position] = coefficient.value;\n        });\n\n        return coefficients;\n    });\n}\n\nexport function getConstantVector(equations: Equals[]): number[] {\n    return equations.map((equation) => {\n        const summands = getSummands(equation);\n        const constants = <NumberNode[]>summands.filter((summand) => summand.type === 'number');\n\n        if (constants.length === 0) {\n            return 0;\n        }\n\n        if (constants.length === 1) {\n            return -constants[0].value;\n        }\n\n        throw 'RuntimeError: cannot resolve multiple constants';\n    });\n}\n"]},"metadata":{},"sourceType":"script"}