{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.find = find;\nexports.replace = replace;\nexports.getSymbolNames = getSymbolNames;\nexports.getVariableNames = getVariableNames;\nexports.containsSymbols = containsSymbols;\nexports.containsVariables = containsVariables;\nexports.resolveNameConflicts = resolveNameConflicts;\nexports.convertOperatorChainToList = convertOperatorChainToList;\nexports.convertListToOperatorChain = convertListToOperatorChain;\nexports.associativeBinaryNodeTypes = exports.binaryNodeTypes = void 0;\n\nvar _Negate = _interopRequireDefault(require(\"../create/Negate\"));\n\nvar _Vector = _interopRequireDefault(require(\"../create/Vector\"));\n\nvar _SymbolNode = _interopRequireDefault(require(\"../create/SymbolNode\"));\n\nvar _contextUtils = require(\"./context-utils\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar binaryNodeTypes = ['and', 'or', 'greater', 'less', 'greaterOrEquals', 'lessOrEquals', 'equals', 'plus', 'minus', 'times', 'divided', 'power'];\nexports.binaryNodeTypes = binaryNodeTypes;\nvar associativeBinaryNodeTypes = ['and', 'or', 'equals', 'plus', 'times'];\nexports.associativeBinaryNodeTypes = associativeBinaryNodeTypes;\n\nfunction find(node, matcher) {\n  var results = [];\n\n  if (matcher(node)) {\n    results.push(node);\n  }\n\n  if (binaryNodeTypes.includes(node.type)) {\n    find(node.left, matcher).forEach(function (item) {\n      return results.push(item);\n    });\n    find(node.right, matcher).forEach(function (item) {\n      return results.push(item);\n    });\n  }\n\n  if (node.type === 'negate') {\n    find(node.value, matcher).forEach(function (item) {\n      return results.push(item);\n    });\n  }\n\n  if (node.type === 'vector') {\n    node.values.forEach(function (value) {\n      return find(value, matcher).forEach(function (item) {\n        return results.push(item);\n      });\n    });\n  }\n\n  if (node.type === 'functionCall') {\n    find(node[\"function\"], matcher).forEach(function (item) {\n      return results.push(item);\n    });\n    node.parameters.forEach(function (parameter) {\n      return find(parameter, matcher).forEach(function (item) {\n        return results.push(item);\n      });\n    });\n  }\n\n  return results;\n}\n\nfunction replace(node, matcher, replacer) {\n  var currentNode = node;\n\n  if (binaryNodeTypes.includes(currentNode.type)) {\n    var left = replace(currentNode.left, matcher, replacer);\n    var right = replace(currentNode.right, matcher, replacer);\n    currentNode = _objectSpread(_objectSpread({}, currentNode), {}, {\n      left: left,\n      right: right\n    });\n  }\n\n  if (currentNode.type === 'negate') {\n    currentNode = (0, _Negate[\"default\"])(replace(currentNode.value, matcher, replacer));\n  }\n\n  if (currentNode.type === 'vector') {\n    currentNode = (0, _Vector[\"default\"])(currentNode.values.map(function (child) {\n      return replace(child, matcher, replacer);\n    }));\n  }\n\n  if (matcher(currentNode)) {\n    return replacer(currentNode);\n  }\n\n  return currentNode;\n}\n\nfunction getSymbolNames(node) {\n  var result = new Set();\n  var symbols = find(node, function (node) {\n    return node.type === 'symbol';\n  });\n  symbols.forEach(function (symbol) {\n    return result.add(symbol.name);\n  });\n  return result;\n}\n\nfunction getVariableNames(node, context) {\n  var symbols = getSymbolNames(node);\n  return _toConsumableArray(symbols.values()).filter(function (symbol) {\n    return !(0, _contextUtils.existsOnStack)(symbol, context);\n  });\n}\n\nfunction containsSymbols(node) {\n  return getSymbolNames(node).size > 0;\n}\n\nfunction containsVariables(node, context) {\n  return getVariableNames(node, context).length > 0;\n}\n\nfunction resolveNameConflicts(node, name) {\n  var newName = name + \"'\";\n\n  var matcher = function matcher(node) {\n    return node.type === 'symbol' && node.name === name;\n  }; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  var replacer = function replacer(_node) {\n    return (0, _SymbolNode[\"default\"])(newName);\n  };\n\n  if (find(node, matcher).length > 0) {\n    var conflictFreeNode = resolveNameConflicts(node, newName);\n    return replace(conflictFreeNode, matcher, replacer);\n  }\n\n  return node;\n}\n\nfunction convertOperatorChainToList(type, node) {\n  if (node.type !== type) {\n    return [node];\n  }\n\n  return [node.left].concat(_toConsumableArray(convertOperatorChainToList(type, node.right)));\n}\n\nfunction convertListToOperatorChain(type, nodes) {\n  if (nodes.length === 0) {\n    throw 'ConversionError: empty list';\n  }\n\n  if (nodes.length === 1) {\n    return nodes[0];\n  }\n\n  var nodesToBeJoined = nodes.slice(0, nodes.length - 2);\n  var startValue = {\n    type: type,\n    left: nodes[nodes.length - 2],\n    right: nodes[nodes.length - 1]\n  };\n  return nodesToBeJoined.reduceRight(function (right, left) {\n    return {\n      type: type,\n      left: left,\n      right: right\n    };\n  }, startValue);\n}","map":{"version":3,"mappings":"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","names":["binaryNodeTypes","associativeBinaryNodeTypes","find","node","matcher","results","push","includes","type","left","forEach","item","right","value","values","parameters","parameter","replace","replacer","currentNode","map","child","getSymbolNames","result","Set","symbols","symbol","add","name","getVariableNames","context","_toConsumableArray","filter","containsSymbols","size","containsVariables","length","resolveNameConflicts","newName","_node","conflictFreeNode","convertOperatorChainToList","convertListToOperatorChain","nodes","nodesToBeJoined","slice","startValue","reduceRight"],"sources":["/home/behrenle/Projects/private/arithmico-calculator/node_modules/@behrenle/number-cruncher/src/utils/symbolic-utils.ts"],"sourcesContent":["import { BinarySyntaxTreeNode, SymbolNode } from './../types/SyntaxTreeNodes';\nimport { Context, SyntaxTreeNode } from '../types';\nimport createNegate from '../create/Negate';\nimport createVector from '../create/Vector';\nimport createSymbolNode from '../create/SymbolNode';\nimport { existsOnStack } from './context-utils';\n\nexport const binaryNodeTypes: BinarySyntaxTreeNode['type'][] = [\n    'and',\n    'or',\n    'greater',\n    'less',\n    'greaterOrEquals',\n    'lessOrEquals',\n    'equals',\n    'plus',\n    'minus',\n    'times',\n    'divided',\n    'power',\n];\n\nexport const associativeBinaryNodeTypes: BinarySyntaxTreeNode['type'][] = ['and', 'or', 'equals', 'plus', 'times'];\n\ntype Matcher = (node: SyntaxTreeNode) => boolean;\ntype Replacer = (node: SyntaxTreeNode) => SyntaxTreeNode;\n\nexport function find(node: SyntaxTreeNode, matcher: Matcher): SyntaxTreeNode[] {\n    const results: SyntaxTreeNode[] = [];\n\n    if (matcher(node)) {\n        results.push(node);\n    }\n\n    if (binaryNodeTypes.includes((<BinarySyntaxTreeNode>node).type)) {\n        find((<BinarySyntaxTreeNode>node).left, matcher).forEach((item) => results.push(item));\n        find((<BinarySyntaxTreeNode>node).right, matcher).forEach((item) => results.push(item));\n    }\n\n    if (node.type === 'negate') {\n        find(node.value, matcher).forEach((item) => results.push(item));\n    }\n\n    if (node.type === 'vector') {\n        node.values.forEach((value) => find(value, matcher).forEach((item) => results.push(item)));\n    }\n\n    if (node.type === 'functionCall') {\n        find(node.function, matcher).forEach((item) => results.push(item));\n        node.parameters.forEach((parameter) => find(parameter, matcher).forEach((item) => results.push(item)));\n    }\n\n    return results;\n}\n\nexport function replace(node: SyntaxTreeNode, matcher: Matcher, replacer: Replacer): SyntaxTreeNode {\n    let currentNode: SyntaxTreeNode = node;\n\n    if (binaryNodeTypes.includes((<BinarySyntaxTreeNode>currentNode).type)) {\n        const left = replace((<BinarySyntaxTreeNode>currentNode).left, matcher, replacer);\n        const right = replace((<BinarySyntaxTreeNode>currentNode).right, matcher, replacer);\n        currentNode = <BinarySyntaxTreeNode>{ ...currentNode, left, right };\n    }\n\n    if (currentNode.type === 'negate') {\n        currentNode = createNegate(replace(currentNode.value, matcher, replacer));\n    }\n\n    if (currentNode.type === 'vector') {\n        currentNode = createVector(currentNode.values.map((child) => replace(child, matcher, replacer)));\n    }\n\n    if (matcher(currentNode)) {\n        return replacer(currentNode);\n    }\n\n    return currentNode;\n}\n\nexport function getSymbolNames(node: SyntaxTreeNode): Set<string> {\n    const result = new Set<string>();\n    const symbols = <SymbolNode[]>find(node, (node) => node.type === 'symbol');\n    symbols.forEach((symbol) => result.add(symbol.name));\n    return result;\n}\n\nexport function getVariableNames(node: SyntaxTreeNode, context: Context): string[] {\n    const symbols = getSymbolNames(node);\n    return [...symbols.values()].filter((symbol) => !existsOnStack(symbol, context));\n}\n\nexport function containsSymbols(node: SyntaxTreeNode): boolean {\n    return getSymbolNames(node).size > 0;\n}\n\nexport function containsVariables(node: SyntaxTreeNode, context: Context): boolean {\n    return getVariableNames(node, context).length > 0;\n}\n\nexport function resolveNameConflicts(node: SyntaxTreeNode, name: string): SyntaxTreeNode {\n    const newName = name + \"'\";\n    const matcher: Matcher = (node: SyntaxTreeNode) => node.type === 'symbol' && node.name === name;\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const replacer: Replacer = (_node: SyntaxTreeNode) => createSymbolNode(newName);\n\n    if (find(node, matcher).length > 0) {\n        const conflictFreeNode = resolveNameConflicts(node, newName);\n        return replace(conflictFreeNode, matcher, replacer);\n    }\n\n    return node;\n}\n\nexport function convertOperatorChainToList(type: BinarySyntaxTreeNode['type'], node: SyntaxTreeNode): SyntaxTreeNode[] {\n    if (node.type !== type) {\n        return [node];\n    }\n\n    return [node.left, ...convertOperatorChainToList(type, node.right)];\n}\n\nexport function convertListToOperatorChain(\n    type: BinarySyntaxTreeNode['type'],\n    nodes: SyntaxTreeNode[],\n): SyntaxTreeNode {\n    if (nodes.length === 0) {\n        throw 'ConversionError: empty list';\n    }\n\n    if (nodes.length === 1) {\n        return nodes[0];\n    }\n\n    const nodesToBeJoined = nodes.slice(0, nodes.length - 2);\n    const startValue: BinarySyntaxTreeNode = { type, left: nodes[nodes.length - 2], right: nodes[nodes.length - 1] };\n\n    return nodesToBeJoined.reduceRight(\n        (right, left) => ({\n            type,\n            left,\n            right,\n        }),\n        startValue,\n    );\n}\n"]},"metadata":{},"sourceType":"script"}