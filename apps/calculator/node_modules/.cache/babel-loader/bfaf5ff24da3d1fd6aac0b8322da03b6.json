{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createOptions = createOptions;\nexports.useStrictContextValidator = useStrictContextValidator;\nexports.existsOnStack = existsOnStack;\nexports.getStackObject = getStackObject;\nexports.insertStackObject = insertStackObject;\nexports.serializeStack = serializeStack;\nexports.defaultOptions = void 0;\n\nvar _serialize = _interopRequireDefault(require(\"../serialize\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar defaultOptions = {\n  decimalPlaces: 6,\n  decimalSeparator: '.',\n  magnitudeThresholdForScientificNotation: 6,\n  angleUnit: 'degrees',\n  config: {\n    load: {\n      mode: 'blacklist',\n      names: []\n    },\n    operators: {\n      define: true,\n      lambda: true,\n      orBooleanBoolean: true,\n      orFunctionFunction: true,\n      andBooleanBoolean: true,\n      andFunctionFunction: true,\n      negateNumber: true,\n      negateBoolean: true,\n      negateFunction: true,\n      equalsNumberNumber: true,\n      equalsBooleanBoolean: true,\n      equalsFunctionFunction: true,\n      lessNumberNumber: true,\n      lessFunctionFunction: true,\n      lessOrEqualsNumberNumber: true,\n      lessOrEqualsFunctionFunction: true,\n      greaterNumberNumber: true,\n      greaterFunctionFunction: true,\n      greaterOrEqualsNumberNumber: true,\n      greaterOrEqualsFunctionFunction: true,\n      plusNumberNumber: true,\n      plusVectorVector: true,\n      plusFunctionFunction: true,\n      minusNumberNumber: true,\n      minusVectorVector: true,\n      minusFunctionFunction: true,\n      timesNumberNumber: true,\n      timesNumberVector: true,\n      timesVectorVector: true,\n      timesVectorMatrix: true,\n      timesMatrixMatrix: true,\n      timesFunctionFunction: true,\n      dividedNumberNumber: true,\n      dividedVectorNumber: true,\n      dividedFunctionFunction: true,\n      powerNumberNumber: true,\n      powerFunctionFunction: true\n    }\n  }\n};\nexports.defaultOptions = defaultOptions;\n\nfunction createOptions(options) {\n  return _objectSpread(_objectSpread({}, defaultOptions), options);\n}\n\nfunction useStrictContextValidator(name, context) {\n  if (context.stack.length === 0) {\n    throw 'ContextError: no stackframes available';\n  }\n}\n\nfunction existsOnStack(name, context) {\n  for (var i = context.stack.length - 1; i >= 0; i--) {\n    var stackFrame = context.stack[i];\n\n    if (stackFrame[name]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getStackObject(name, context) {\n  for (var i = context.stack.length - 1; i >= 0; i--) {\n    var stackFrame = context.stack[i];\n\n    if (stackFrame[name]) {\n      return stackFrame[name];\n    }\n  }\n}\n\nfunction insertStackObject(name, stackObject, context) {\n  useStrictContextValidator(name, context);\n  var stackFrameIndex = context.stack.length - 1;\n  return _objectSpread(_objectSpread({}, context), {}, {\n    stack: context.stack.map(function (stackFrame, index) {\n      return index === stackFrameIndex ? _objectSpread(_objectSpread({}, context.stack[stackFrameIndex]), {}, _defineProperty({}, name, stackObject)) : stackFrame;\n    })\n  });\n}\n\nfunction serializeStack(context) {\n  if (context.stack.length === 0) {\n    return {};\n  }\n\n  return Object.fromEntries(Object.entries(context.stack[context.stack.length - 1]).map(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        name = _ref2[0],\n        node = _ref2[1];\n\n    return [name, (0, _serialize[\"default\"])(node, context.options)];\n  }));\n}","map":{"version":3,"mappings":"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","names":["defaultOptions","decimalPlaces","decimalSeparator","magnitudeThresholdForScientificNotation","angleUnit","config","load","mode","names","operators","define","lambda","orBooleanBoolean","orFunctionFunction","andBooleanBoolean","andFunctionFunction","negateNumber","negateBoolean","negateFunction","equalsNumberNumber","equalsBooleanBoolean","equalsFunctionFunction","lessNumberNumber","lessFunctionFunction","lessOrEqualsNumberNumber","lessOrEqualsFunctionFunction","greaterNumberNumber","greaterFunctionFunction","greaterOrEqualsNumberNumber","greaterOrEqualsFunctionFunction","plusNumberNumber","plusVectorVector","plusFunctionFunction","minusNumberNumber","minusVectorVector","minusFunctionFunction","timesNumberNumber","timesNumberVector","timesVectorVector","timesVectorMatrix","timesMatrixMatrix","timesFunctionFunction","dividedNumberNumber","dividedVectorNumber","dividedFunctionFunction","powerNumberNumber","powerFunctionFunction","createOptions","options","useStrictContextValidator","name","context","stack","length","existsOnStack","i","stackFrame","getStackObject","insertStackObject","stackObject","stackFrameIndex","map","index","serializeStack","Object","fromEntries","entries","node"],"sources":["/home/behrenle/Projects/private/arithmico-calculator/node_modules/@behrenle/number-cruncher/src/utils/context-utils.ts"],"sourcesContent":["import serialize from '../serialize';\nimport { Context, Options, SyntaxTreeNode } from '../types';\n\nexport const defaultOptions: Options = {\n    decimalPlaces: 6,\n    decimalSeparator: '.',\n    magnitudeThresholdForScientificNotation: 6,\n    angleUnit: 'degrees',\n    config: {\n        load: {\n            mode: 'blacklist',\n            names: [],\n        },\n        operators: {\n            define: true,\n            lambda: true,\n\n            orBooleanBoolean: true,\n            orFunctionFunction: true,\n\n            andBooleanBoolean: true,\n            andFunctionFunction: true,\n\n            negateNumber: true,\n            negateBoolean: true,\n            negateFunction: true,\n\n            equalsNumberNumber: true,\n            equalsBooleanBoolean: true,\n            equalsFunctionFunction: true,\n\n            lessNumberNumber: true,\n            lessFunctionFunction: true,\n\n            lessOrEqualsNumberNumber: true,\n            lessOrEqualsFunctionFunction: true,\n\n            greaterNumberNumber: true,\n            greaterFunctionFunction: true,\n\n            greaterOrEqualsNumberNumber: true,\n            greaterOrEqualsFunctionFunction: true,\n\n            plusNumberNumber: true,\n            plusVectorVector: true,\n            plusFunctionFunction: true,\n\n            minusNumberNumber: true,\n            minusVectorVector: true,\n            minusFunctionFunction: true,\n\n            timesNumberNumber: true,\n            timesNumberVector: true,\n            timesVectorVector: true,\n            timesVectorMatrix: true,\n            timesMatrixMatrix: true,\n            timesFunctionFunction: true,\n\n            dividedNumberNumber: true,\n            dividedVectorNumber: true,\n            dividedFunctionFunction: true,\n\n            powerNumberNumber: true,\n            powerFunctionFunction: true,\n        },\n    },\n};\n\nexport function createOptions(options?: Partial<Options>): Options {\n    return { ...defaultOptions, ...options };\n}\n\nexport function useStrictContextValidator(name: string, context: Context) {\n    if (context.stack.length === 0) {\n        throw 'ContextError: no stackframes available';\n    }\n}\n\nexport function existsOnStack(name: string, context: Context) {\n    for (let i = context.stack.length - 1; i >= 0; i--) {\n        const stackFrame = context.stack[i];\n\n        if (stackFrame[name]) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nexport function getStackObject(name: string, context: Context) {\n    for (let i = context.stack.length - 1; i >= 0; i--) {\n        const stackFrame = context.stack[i];\n\n        if (stackFrame[name]) {\n            return stackFrame[name];\n        }\n    }\n}\n\nexport function insertStackObject(name: string, stackObject: SyntaxTreeNode, context: Context): Context {\n    useStrictContextValidator(name, context);\n    const stackFrameIndex = context.stack.length - 1;\n    return {\n        ...context,\n        stack: context.stack.map((stackFrame, index) =>\n            index === stackFrameIndex\n                ? {\n                      ...context.stack[stackFrameIndex],\n                      [name]: stackObject,\n                  }\n                : stackFrame,\n        ),\n    };\n}\n\nexport function serializeStack(context: Context): Record<string, string> {\n    if (context.stack.length === 0) {\n        return {};\n    }\n\n    return Object.fromEntries(\n        Object.entries(context.stack[context.stack.length - 1]).map(([name, node]) => [\n            name,\n            serialize(node, context.options),\n        ]),\n    );\n}\n"]},"metadata":{},"sourceType":"script"}