{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = loadPlugins;\n\nvar _contextUtils = require(\"./context-utils\");\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction loadPluginFunction(pluginFunction, context) {\n  return (0, _contextUtils.insertStackObject)(pluginFunction.name, pluginFunction[\"function\"], context);\n}\n\nfunction loadPluginConstant(pluginConstant, context) {\n  return (0, _contextUtils.insertStackObject)(pluginConstant.name, pluginConstant.value, context);\n}\n\nfunction loadPlugin(plugin, context) {\n  var contextWithFunctions = plugin.functions.filter(function (func) {\n    if (context.options.config.load.mode === 'blacklist') {\n      return !context.options.config.load.names.includes(func.name);\n    } else {\n      return !context.options.config.load.names.includes(func.name);\n    }\n  }).reduce(function (context, func) {\n    return loadPluginFunction(func, context);\n  }, context);\n  var contextWithConstants = plugin.constants.filter(function (constant) {\n    if (context.options.config.load.mode === 'blacklist') {\n      return !context.options.config.load.names.includes(constant.name);\n    } else {\n      return !context.options.config.load.names.includes(constant.name);\n    }\n  }).reduce(function (context, constant) {\n    return loadPluginConstant(constant, context);\n  }, contextWithFunctions);\n  return contextWithConstants;\n}\n\nfunction loadPluginDocumentation(plugin) {\n  var docs = [];\n  plugin.functions.forEach(function (func) {\n    return docs.push({\n      plugin: plugin.name,\n      type: 'function',\n      documentation: func.documentation\n    });\n  });\n  plugin.constants.forEach(function (constant) {\n    return docs.push({\n      plugin: plugin.name,\n      type: 'constant',\n      documentation: constant.documentation\n    });\n  }); // todo inline definitions\n\n  return docs;\n}\n\nfunction loadPlugins(plugins, options) {\n  var log = [];\n  var excludedPlugins = [];\n  var loadingErrorOccured = true;\n  var context;\n  var documentation;\n  log.push('Loading plugins...');\n\n  while (loadingErrorOccured) {\n    log.push(excludedPlugins.length === 0 ? 'initialize empty stack' : 'reset stack');\n    loadingErrorOccured = false;\n    context = {\n      options: options,\n      stack: [{}]\n    };\n    documentation = [];\n    plugins.filter(function (plugin) {\n      return !excludedPlugins.includes(plugin.name);\n    }).forEach(function (plugin) {\n      try {\n        context = loadPlugin(plugin, context);\n        documentation = [].concat(_toConsumableArray(documentation), _toConsumableArray(loadPluginDocumentation(plugin)));\n        log.push(\"Successfully loaded plugin \".concat(plugin.name));\n      } catch (loadingError) {\n        loadingErrorOccured = true;\n        excludedPlugins.push(plugin.name);\n        log.push(\"Failed to load plugin \".concat(plugin.name, \": \").concat(loadingError));\n      }\n    });\n  }\n\n  log.push(\"Loading completed excluded plugins: [\".concat(excludedPlugins.join(', '), \"]\"));\n  context.stack.push({});\n  return {\n    context: context,\n    log: log,\n    documentation: documentation\n  };\n}","map":{"version":3,"mappings":"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","names":["loadPluginFunction","pluginFunction","context","name","loadPluginConstant","pluginConstant","value","loadPlugin","plugin","contextWithFunctions","functions","filter","func","options","config","load","mode","names","includes","reduce","contextWithConstants","constants","constant","loadPluginDocumentation","docs","forEach","push","type","documentation","loadPlugins","plugins","log","excludedPlugins","loadingErrorOccured","length","stack","loadingError","join"],"sources":["/home/behrenle/Projects/private/arithmico-calculator/node_modules/@behrenle/number-cruncher/src/utils/plugin-loader.ts"],"sourcesContent":["import { GlobalDocumentationItem } from './../types/Plugin';\nimport { Context, Plugin, PluginFunction, PluginConstant, Options } from '../types';\nimport { insertStackObject } from './context-utils';\n\nfunction loadPluginFunction(pluginFunction: PluginFunction, context: Context): Context {\n    return insertStackObject(pluginFunction.name, pluginFunction.function, context);\n}\n\nfunction loadPluginConstant(pluginConstant: PluginConstant, context: Context): Context {\n    return insertStackObject(pluginConstant.name, pluginConstant.value, context);\n}\n\nfunction loadPlugin(plugin: Plugin, context: Context): Context {\n    const contextWithFunctions = plugin.functions\n        .filter((func) => {\n            if (context.options.config.load.mode === 'blacklist') {\n                return !context.options.config.load.names.includes(func.name);\n            } else {\n                return !context.options.config.load.names.includes(func.name);\n            }\n        })\n        .reduce((context, func) => loadPluginFunction(func, context), context);\n\n    const contextWithConstants = plugin.constants\n        .filter((constant) => {\n            if (context.options.config.load.mode === 'blacklist') {\n                return !context.options.config.load.names.includes(constant.name);\n            } else {\n                return !context.options.config.load.names.includes(constant.name);\n            }\n        })\n        .reduce((context, constant) => loadPluginConstant(constant, context), contextWithFunctions);\n\n    return contextWithConstants;\n}\n\nfunction loadPluginDocumentation(plugin: Plugin): GlobalDocumentationItem[] {\n    const docs: GlobalDocumentationItem[] = [];\n    plugin.functions.forEach((func) =>\n        docs.push({\n            plugin: plugin.name,\n            type: 'function',\n            documentation: func.documentation,\n        }),\n    );\n    plugin.constants.forEach((constant) =>\n        docs.push({\n            plugin: plugin.name,\n            type: 'constant',\n            documentation: constant.documentation,\n        }),\n    );\n    // todo inline definitions\n    return docs;\n}\n\ninterface LoadPluginsResult {\n    log: string[];\n    context: Context;\n    documentation: GlobalDocumentationItem[];\n}\n\nexport default function loadPlugins(plugins: Plugin[], options: Options): LoadPluginsResult {\n    const log: string[] = [];\n    const excludedPlugins: string[] = [];\n    let loadingErrorOccured = true;\n    let context: Context;\n    let documentation: GlobalDocumentationItem[];\n\n    log.push('Loading plugins...');\n    while (loadingErrorOccured) {\n        log.push(excludedPlugins.length === 0 ? 'initialize empty stack' : 'reset stack');\n        loadingErrorOccured = false;\n        context = {\n            options,\n            stack: [{}],\n        };\n        documentation = [];\n\n        plugins\n            .filter((plugin) => !excludedPlugins.includes(plugin.name))\n            .forEach((plugin) => {\n                try {\n                    context = loadPlugin(plugin, context);\n                    documentation = [...documentation, ...loadPluginDocumentation(plugin)];\n                    log.push(`Successfully loaded plugin ${plugin.name}`);\n                } catch (loadingError) {\n                    loadingErrorOccured = true;\n                    excludedPlugins.push(plugin.name);\n                    log.push(`Failed to load plugin ${plugin.name}: ${loadingError}`);\n                }\n            });\n    }\n    log.push(`Loading completed excluded plugins: [${excludedPlugins.join(', ')}]`);\n    context.stack.push({});\n    return { context, log, documentation };\n}\n"]},"metadata":{},"sourceType":"script"}