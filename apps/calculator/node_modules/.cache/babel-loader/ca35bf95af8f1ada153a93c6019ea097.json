{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createBinaryOperatorFunctionComposition = createBinaryOperatorFunctionComposition;\n\nvar _Lambda = _interopRequireDefault(require(\"../create/Lambda\"));\n\nvar _SymbolNode = _interopRequireDefault(require(\"../create/SymbolNode\"));\n\nvar _eval = _interopRequireDefault(require(\"../eval\"));\n\nvar _parameterUtils = require(\"./parameter-utils\");\n\nvar _symbolicUtils = require(\"./symbolic-utils\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction createBinaryOperatorFunctionComposition(leftFunc, rightFunc, binaryOperatorCreator, context) {\n  if (!(0, _parameterUtils.compareFunctionHeaders)(leftFunc.header, rightFunc.header)) {\n    throw \"TypeError: incompatible function signatures\";\n  }\n\n  var rightExpression = leftFunc.header.reduce(function (expr, headerItem, index) {\n    var exprWithoutNameConflicts = headerItem.name !== rightFunc.header[index].name ? (0, _symbolicUtils.resolveNameConflicts)(expr, headerItem.name) : expr;\n    return (0, _symbolicUtils.replace)(exprWithoutNameConflicts, function (node) {\n      return node.type === 'symbol' && node.name === rightFunc.header[index].name;\n    }, // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    function (_node) {\n      return (0, _SymbolNode[\"default\"])(headerItem.name);\n    });\n  }, rightFunc.expression);\n  return (0, _eval[\"default\"])((0, _Lambda[\"default\"])(leftFunc.header, binaryOperatorCreator(leftFunc.expression, rightExpression)), context);\n}","map":{"version":3,"mappings":";;;;;;;AAAA;;AACA;;AACA;;AAEA;;AACA;;;;;;;;AAEO,SAASA,uCAAT,CACHC,QADG,EAEHC,SAFG,EAGHC,qBAHG,EAIHC,OAJG,EAKL;EACE,IAAI,CAAC,4CAAuBH,QAAQ,CAACI,MAAhC,EAAwCH,SAAS,CAACG,MAAlD,CAAL,EAAgE;IAC5D;EACH;;EAED,IAAMC,eAAe,GAAGL,QAAQ,CAACI,MAATJ,CAAgBM,MAAhBN,CAAuB,UAACO,IAAD,EAAOC,UAAP,EAAmBC,KAAnB,EAA6B;IACxE,IAAMC,wBAAwB,GAC1BF,UAAU,CAACG,IAAXH,KAAoBP,SAAS,CAACG,MAAVH,CAAiBQ,KAAjBR,EAAwBU,IAA5CH,GAAmD,yCAAqBD,IAArB,EAA2BC,UAAU,CAACG,IAAtC,CAAnDH,GAAiGD,IADrG;IAGA,OAAO,4BACHG,wBADG,EAEH,UAACE,IAAD;MAAA,OAA0BA,IAAI,CAACC,IAALD,KAAc,QAAdA,IAA0BA,IAAI,CAACD,IAALC,KAAcX,SAAS,CAACG,MAAVH,CAAiBQ,KAAjBR,EAAwBU,IAA1F;IAFG,GAGH;IACA,UAACG,KAAD;MAAA,OAA2B,4BAAiBN,UAAU,CAACG,IAA5B,CAA3B;IAJG,EAAP;EAJoB,GAUrBV,SAAS,CAACc,UAVWf,CAAxB;EAYA,OAAO,sBACH,wBAAaA,QAAQ,CAACI,MAAtB,EAA8BF,qBAAqB,CAACF,QAAQ,CAACe,UAAV,EAAsBV,eAAtB,CAAnD,CADG,EAEHF,OAFG,CAAP;AAIH","names":["createBinaryOperatorFunctionComposition","leftFunc","rightFunc","binaryOperatorCreator","context","header","rightExpression","reduce","expr","headerItem","index","exprWithoutNameConflicts","name","node","type","_node","expression"],"sources":["/home/behrenle/Projects/private/arithmico-calculator/node_modules/@behrenle/number-cruncher/src/utils/compose-function-utils.ts"],"sourcesContent":["import createLambda from '../create/Lambda';\nimport createSymbolNode from '../create/SymbolNode';\nimport evaluate from '../eval';\nimport { Context, FunctionNode, SyntaxTreeNode } from '../types';\nimport { compareFunctionHeaders } from './parameter-utils';\nimport { replace, resolveNameConflicts } from './symbolic-utils';\n\nexport function createBinaryOperatorFunctionComposition(\n    leftFunc: FunctionNode,\n    rightFunc: FunctionNode,\n    binaryOperatorCreator: (left: SyntaxTreeNode, right: SyntaxTreeNode) => SyntaxTreeNode,\n    context: Context,\n) {\n    if (!compareFunctionHeaders(leftFunc.header, rightFunc.header)) {\n        throw `TypeError: incompatible function signatures`;\n    }\n\n    const rightExpression = leftFunc.header.reduce((expr, headerItem, index) => {\n        const exprWithoutNameConflicts =\n            headerItem.name !== rightFunc.header[index].name ? resolveNameConflicts(expr, headerItem.name) : expr;\n\n        return replace(\n            exprWithoutNameConflicts,\n            (node: SyntaxTreeNode) => node.type === 'symbol' && node.name === rightFunc.header[index].name,\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            (_node: SyntaxTreeNode) => createSymbolNode(headerItem.name),\n        );\n    }, rightFunc.expression);\n\n    return evaluate(\n        createLambda(leftFunc.header, binaryOperatorCreator(leftFunc.expression, rightExpression)),\n        context,\n    );\n}\n"]},"metadata":{},"sourceType":"script"}